<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>Healthhub.healthhub API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Healthhub.healthhub</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
import glob as glob
import SimpleITK as sitk
from tqdm import tqdm
import cv2
import pydicom
import os
import matplotlib.pyplot as plt
from PIL import Image
from tabulate import tabulate
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from skimage import measure, feature

from scipy.spatial import distance
import skimage

import glob as glob
import SimpleITK as sitk
from tqdm import tqdm
import cv2
import pydicom
import os
import matplotlib.pyplot as plt
from tabulate import tabulate
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d.art3d import Poly3DCollection
from skimage import measure, feature
from PIL import Image
import numpy as np
import matplotlib.pyplot as plt
import os
from skimage import color
from skimage import io
import cv2
import math
from matplotlib import image
from matplotlib import pyplot
from scipy import ndimage

import numpy as np
import ipywidgets as ipyw
import matplotlib.pyplot as plt
import pydicom
from pydicom.data import get_testdata_files
from pydicom.filereader import read_dicomdir




class healthhub:
    def __init__(self):
        self.dicom=dicom()
        self.image=Image_class()
        self.CV=CV()
        
        
class dicom:

    def __init__(self):
        self.read=read()
        self.modify=modify()
        self.display=display()
        #self.process=process()
        
        
class display:
    &#34;&#34;&#34;
    A class to represent display.

    ...

    Attributes
    ----------
    name : volume
        3d volume array
    

    Methods
    -------
    multipleSlice(volume):
        Plot the multiple slices of a given volume
    
    plotSlice(image):
        Plots the 2D plot of given slice image  
    
    display3D(volume):
        Plots the 3D plot given numpy array
    
    intensityHist(array):
        it will plot intensity histogram of given array        
           
    
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;
        Constructs all the necessary attributes for the diplay object.
        &#34;&#34;&#34;

        pass
        
    def multipleSlice(self,volume):
        &#39;&#39;&#39;
        allows the user to navigate through different slices by using a slider widget
        
        Parameters:
        volume (int)(float): A 3d numpy array

        Returns:
                Mutiple slices (int)(float): axial , coronal and sagittal slices 
        &#39;&#39;&#39;

        figsize = (100,100)
        cmap = &#39;gray&#39;
        v = [np.min(volume), np.max(volume)] 

        def views():
            def plot_slice(z1, z2, z3):
                # Plot slice for the given plane and slice
                f,ax = plt.subplots(1,3, figsize=figsize)
                #print(self.figsize)
                #self.fig = plt.figure(figsize=self.figsize)
                #f(figsize = self.figsize)
                ax[0].imshow(vol1[:,:,z1], cmap=plt.get_cmap(cmap), 
                    vmin=v[0], vmax=v[1])
                ax[1].imshow(vol2[:,:,z2], cmap=plt.get_cmap(cmap), 
                    vmin=v[0], vmax=v[1])
                ax[2].imshow(vol3[:,:,z3], cmap=plt.get_cmap(cmap), 
                    vmin=v[0], vmax=v[1])
                plt.show()

            vol1 = np.transpose(volume, [1,2,0])
            vol2 = np.rot90(np.transpose(volume, [2,0,1]), 3) #rotate 270 degrees
            vol3 = np.transpose(volume, [0,1,2])
            maxZ1 = vol1.shape[2] - 1
            maxZ2 = vol2.shape[2] - 1
            maxZ3 = vol3.shape[2] - 1
            ipyw.interact(plot_slice, 
                z1=ipyw.IntSlider(min=0, max=maxZ1, step=1, continuous_update=False, 
                description=&#39;Axial:&#39;), 
                z2=ipyw.IntSlider(min=0, max=maxZ2, step=1, continuous_update=False, 
                description=&#39;Coronal:&#39;),
                z3=ipyw.IntSlider(min=0, max=maxZ3, step=1, continuous_update=False, 
            description=&#39;Sagittal:&#39;))

        ipyw.interact(views)

    def plotSlice(self, image):
        &#39;&#39;&#39;
        Returns the 2D plot of given slice image        
        Parameters:
                image (int)(float): A 2d numpy array

        Returns:
                Plot an Image  
        &#39;&#39;&#39;        
        plt.imshow(image,&#39;gray&#39;)
        

    def display3D(self,volume):
        &#39;&#39;&#39;Returns the 3D plot given numpy array
        
        Parameters:
                image (int)(float): A 3d numpy array

        Returns:
                Plot 3d Image  
        &#39;&#39;&#39;

        p=volume.transpose(2,1,0)
        p = p[:,:,::-1]
        threshold=0.5
        alpha=0.5
        verts, faces, norm, val = measure.marching_cubes_lewiner(p, threshold)

        fig = plt.figure(figsize=(20, 20))
        ax = fig.add_subplot(111, projection=&#39;3d&#39;)

        # Fancy indexing: `verts[faces]` to generate a collection of triangles
        mesh = Poly3DCollection(verts[faces], alpha=alpha)
        face_color = [0.8, 0.2, 1]
        mesh.set_facecolor(face_color)
        ax.add_collection3d(mesh)

        ax.set_xlim(0, p.shape[0])
        ax.set_ylim(0, p.shape[1])
        ax.set_zlim(0, p.shape[2])

        plt.show()

    def intensityHist(self,array):
        
        &#39;&#39;&#39;
        it will plot intensity histogram of given array        
        Parameters:
                image (int)(float): A 2d or 3d numpy array

        Returns:
                Plots Image histogram  
        &#39;&#39;&#39;
        array = np.array(array)

        [counts,bins,bars]=plt.hist(array.flatten())     
        
class read:
    &#34;&#34;&#34;
    A class to represent read.

    ...

    Attributes
    ----------
    name : None
    

    Methods
    -------
     
    scan(folder_path): 
        it will  take path of scan as input and return scan array in 4d and its metadeta
        
    Slice(slice_path):
        it will  take path of slice as input and return slice array  and its metadeta
        
    tag(tags,ds):
         it will  return the given tags values 
        
    getSeriesPlane(ds):
         it will  return the  tags with in getSeriesPlane 
    
    orientation(self,orientation_tag_value): 
         it will  return orientation tag value as a type string
         
    seriesData(ds):   
         it will  returns a list of sopseriesUID, series_number, view corresponding to each series

    
    getImagePlane(self,meta_data):  
         it will  returns  all the tags within ImagePlane  module
         
    getFrameOfReference(self,meta_data): ##Public func
         it will  returns  all the tags within FrameOfReference  module
         
    getPatientStudy(self,meta_data):
         it will  returns  all the tags within getPatientStudy  module
         
    getGeneralStudy(self,meta_data): 
         it will  returns  all the tags within getGeneralStudy  module
        
    getImagePixel(meta_data):    
          it will  returns  all the tags within getImagePixel  module
        
        
    &#34;&#34;&#34;

    def __init__(self):#, folder_path):
        &#34;&#34;&#34;
        Constructs all the necessary attributes for the diplay object.

        Parameters
        ----------
            name : None
            
        &#34;&#34;&#34;

        pass
        #super().__init__()

    def scan(self,folder_path): ##Public func
        &#39;&#39;&#39;
        it will  take path of scan as input and return scan array in 4d and its metadeta
        
        Parameters:
                folder_path : path of given dicom scan

        Returns:
                (int)(float): Scan 
                            : Meta Data
        &#39;&#39;&#39;        
       
        
        files = self.sorted_files(folder_path)
        f, myscan, mytags = self.read_scan(folder_path,files)
        return myscan, mytags

    def sorted_files(self,folder): ##Private function
        ins=[]
        ori = []
        ser=[]
        f= os.listdir(folder)
        for name in tqdm(f):
            itkimage = sitk.ReadImage(os.path.join(folder,name))
            temp= float(itkimage.GetMetaData(&#39;0020|0013&#39;)) # instance number 
            temp1= itkimage.GetMetaData(&#39;0020|000e&#39;) #series instance UID 
            ins.append(int(temp))
            ser.append(temp1)
        series=np.unique(ser)

        files=[[x for sr,_,x in sorted(zip(ser,ins,f)) if sr==s] for s in series]
        return files


    def read_scan(self,folder_path,files): ##Private func
        axial  =  np.array([1., 0., 0., 0., 1., 0.])
        coronal = np.array([1., 0., 0., 0., 0., -1.])
        sagittal= np.array([0., 1., 0., 0., 0., -1.])
        myscan = []
        mytags = []
        f=[]
        for i in tqdm (range (len(files))):
            img=[]
            file=[]
            tags = []
            for filename in files[i]:
                ds = pydicom.dcmread(os.path.join(folder_path,filename))
                numpyImage = ds.pixel_array
                del ds[0x7fe0, 0x0010]
                img.append(numpyImage)
                file.append(filename)
                tags.append(ds)
            mytags.append(tags)
            myscan.append(img)
            f.append(file)
        return f, myscan, mytags

    def Slice(self, slice_path): ##Public
        &#39;&#39;&#39;
        it will  take path of slice as input and return slice array  and its metadeta
        
        Parameters:
                folder_path : path of given dicom scan

        Returns:
                (int)(float): Slice 
                            : Meta Data
        &#39;&#39;&#39;        
        ds = pydicom.dcmread(slice_path)
        numpyImage = ds.pixel_array
        return numpyImage, ds

    #def seriesPlaneData(self): ##public
    #    &#39;&#39;&#39;it will  display module series plane data&#39;&#39;&#39;
    #    print(&#39;Series Orientation: &#39;,self.orient)
    #    print(&#39;Series Instance UID: &#39;,self.series_ins_uid)
    #    return self.orient,self.series_ins_uid

    def tag(self,tags,ds): ##Public
        &#39;&#39;&#39;it will  return the given tags values 
        
        Parameters:
                tags : any tags of given dicom scan
                ds : meta deta of dicom scan

        Returns:
                (int)(float)(String): Tag Value 
                            
        &#39;&#39;&#39;
        (x1,x2) = tags
        if (x1,x2) in ds:
            print(ds[x1,x2])
            return ds[x1,x2].value
        else:
            print(&#39;Tag not found&#39;)
    
    ###
    def getSeriesPlane(self,ds): ##public
        &#39;&#39;&#39;it will  return the  tags with in getSeriesPlane 
        
        Parameters:
                ds= meta deta
                
        Returns:
                Series Orientation, Series Instance UID                            
        &#39;&#39;&#39;
        l=[]
        if ((0x0020,0x0037) in ds):
            o=ds[0x0020,0x0037].value
            
        else:
            o=&#39;&#39;
        if ((0x0020,0x000e) in ds):
            s=ds[0x0020,0x000e].value
            #print(&#34;hi&#34;)
        else:
            s=&#39;&#39;
        l.append([o,s])

        return l

    

    def orientation(self,orientation_tag_value): ##Public func
        &#39;&#39;&#39;
        it will  return orientation tag value as a type string
        
        Parameters:
                orientation_tag_value : orientation tag

        Returns:
                (string): Orientation of tag [axial, sagittal or coronal] 
                        
        &#39;&#39;&#39;
        axial  =  np.array([1., 0., 0., 0., 1., 0.])
        coronal = np.array([1., 0., 0., 0., 0., -1.])
        sagittal= np.array([0., 1., 0., 0., 0., -1.])

        a = np.around(orientation_tag_value)

        if (a==coronal).all():
            return &#39;coronal&#39;
        elif (a==axial).all():
            return &#39;axial&#39;
        elif (a==sagittal).all():
            return &#39;sagittal&#39;
        else:
            print(&#39;orientation not found&#39;)
            return &#39;&#39;

    def seriesData(self,ds):   ##Public func
        &#39;&#39;&#39;it will  returns a list of sopseriesUID, series_number, view corresponding to each series
         Parameters:
                ds  :  scan meta deta

        Returns:
                (list):  [sopseriesUID, series_number, view corresponding to each series] 
                        
        &#39;&#39;&#39;

        n=len(ds)
        l=[]
        for i in range(n):
            a = ds[i][0][0x0020,0x000e].value if ((0x0020,0x000e) in ds[i][0]) else &#39;&#39;
            if ((0x0020,0x0037) in ds[i][0]):
                b = self.orientation(ds[i][0][0x0020,0x0037].value)
            else:
                b = &#39;no orientation tag&#39;
            #b = ds[i][0][0x0020,0x0037].value if ((0x0020,0x0037) in ds[i][0]) else &#39;&#39;
            c = ds[i][0][0x0020,0x0011].value if ((0x0020,0x0011) in ds[i][0]) else &#39;&#39;
            l.append([a,b,c])

        return l




    def getImagePlane(self,meta_data):  ##Public func
        #Pixel Spacing
        &#39;&#39;&#39;it will  returns  all the tags within ImagePlane  module
         Parameters:
                ds  :  scan meta deta

        Returns:
                table : Tag Name, Tag Code and Tag Values with in imagePlane Module 
                        
        &#39;&#39;&#39;
        data =meta_data.group_dataset(0x0020)


        #col_names = [&#34;Tag Name&#34;, &#34;Tag Code&#34;,&#34;Tag Value&#34;]
        #print(tabulate(data, headers=col_names))
        return data



    def getFrameOfReference(self,meta_data): ##Public func
        &#39;&#39;&#39;it will  returns  all the tags within FrameOfReference  module
         Parameters:
                ds  :  scan meta deta

         Returns:
                table : Tag Name, Tag Code and Tag Values with in FrameOfReference Module 
                        
         &#39;&#39;&#39;
        data = meta_data.group_dataset(0x0020)

       # print(data)
        return data

    def getPatientStudy(self,meta_data):
        &#39;&#39;&#39;it will  returns  all the tags within getPatientStudy  module
         Parameters:
                ds  :  scan meta deta

         Returns:
                table : Tag Name, Tag Code and Tag Values with in getPatientStudy Module 
                        
         &#39;&#39;&#39;   
        data=meta_data.group_dataset(0x0010)

        #col_names = [&#34;Tag Name&#34;, &#34;Tag Code&#34;,&#34;Tag Value&#34;]

        #print(data)
        return data


    def getGeneralStudy(self,meta_data): ##Public func
        &#39;&#39;&#39;it will  returns  all the tags within getGeneralStudy  module
         Parameters:
                ds  :  scan meta deta

         Returns:
                table : Tag Name, Tag Code and Tag Values with in getGeneralStudy Module 
                        
        &#39;&#39;&#39;   
       

        data =meta_data.group_dataset(0x0008) 

        #print(data)
        return data

    def getImagePixel(self,meta_data):    ##Public func
        &#39;&#39;&#39;it will  returns  all the tags within getImagePixel  module
         Parameters:
                ds  :  scan meta deta

         Returns:
                table : Tag Name, Tag Code and Tag Values with in getImagePixel Module 
                        
        &#39;&#39;&#39;
        data = meta_data.group_dataset(0x0028) 

            #    [&#34;Bits Stored &#34;, &#34;(0008,0101)&#34;,meta_data[0x0028,0x0101].value],
             #   [&#34;High Bit &#34;, &#34;(0008,0102)&#34;,meta_data[0x0028,0x0102].value],
             #   [&#34;Pixel Representation &#34;, &#34;(0008,0103)&#34;,meta_data[0x0028,0x0103].value]]
        #col_names = [&#34;Tag Name&#34;, &#34;Tag Code&#34;,&#34;Tag Value&#34;]

        #print(data)
        return data
    
    
class modify:
    &#34;&#34;&#34;
    A class to represent modify.

    ...

    Attributes
    ----------
    name : None
    

    Methods
    -------
    
    tag(tags,ds,value):
        it will  modify   tags  values in scan meta data
         
    image(ds,image):
        This function saves the provided image (rgb or gray scale) in the dataset
       


    maxDiameter(full_mask,spacing):
        This function finds the max diameter of 3D object
         
    &#34;&#34;&#34;

    def __init__(self):
        
        pass
        &#34;&#34;&#34;
        Constructs all the necessary attributes for the diplay object.

        Parameters
        ----------
            name : None
            
        &#34;&#34;&#34;


    def tag(self,tags,ds,value):
        &#39;&#39;&#39;it will  modify   tags  values in scan meta data
         Parameters:
                ds  :  scan meta deta
                tags : tag number to modify
                value : new value for the tag

        Returns:
                ds : Meta data with new tag value 
                        
        &#39;&#39;&#39;        
        (x1,x2) = tags
        if (x1,x2) in ds:
            print(&#39;tag name: &#39;,ds[x1,x2].keyword)
            print(&#39;previous value: &#39;,ds[x1,x2].value)
            ds[x1,x2].value = value
            print(&#39;new value: &#39;,ds[x1,x2].value)
        else:
            print(&#39;Tag not found&#39;)
        return ds

    def image(self,image,output_path,dummy_dcm_path=&#39;&#39;):
        &#39;&#39;&#39;
        This function saves the provided image (rgb or gray scale) in the dataset
        Parameters:
                ds  :  scan meta deta
                image : numpy array
                

        Returns:
                ds : Meta data with image value 
                        
        &#39;&#39;&#39;
        if dummy_dcm_path==&#39;&#39;:
            dummy_dcm_path = &#39;dummy.dcm&#39;
        
        ds = pydicom.dcmread(dummy_dcm_path)
        
        ds.Rows = image.shape[0]
        ds.Columns = image.shape[1]

        if len(image.shape)&gt;2: ##rgb
            image = image.astype(np.uint8)
            ds.PhotometricInterpretation = &#39;RGB&#39;
            ds.PixelRepresentation = 0
            ds.WindowCenter = 127.5
            ds.WindowWidth = 255.0
            ds.SamplesPerPixel = 3
            ds.BitsAllocated = 8
            ds.BitsStored = 8
            ds.HighBit = 7
            if (0x0028, 0x0006) in ds:
                ds[0x0028, 0x0006].vaue = 0
            else:
                ds.add_new(0x00280006, &#39;US&#39;, 0)
        else:
            image = image.astype(np.int16)
        if (0x7fe0, 0x0010) in ds:
            ds.PixelData = image.tobytes()
        else:
            ds.add_new([0x7fe0, 0x0010], &#39;OB&#39;, image.tobytes())
        ds.save_as(output_path)



    def maxDiameter(full_mask,spacing):
        
        &#39;&#39;&#39;
        This function finds the max diameter of 3D object
         Parameters:
                full_mask  : it should contain all the slices of nodule
                spacing : pixel spacing
                

         Returns:
                ds : Meta data with image value 
                        
        &#39;&#39;&#39;
        # Ful mask means that it should contain all the slices of nodule, so shape can be like [6,45,45]
        # spacing is array contains spacing of x,y and z axis, shape should be like [0.7,1.5]

    #     full_mask = edge_mask(full_mask);    
        all_points = np.where(full_mask&gt;0)
        x_coor = all_points[1]
        y_coor = all_points[2]
        z_coor = all_points[0]

        pairs = []
        coordinates = []
    #     print(&#39;Number of points is {}&#39;.format(z_coor.min()))

        for i in range(z_coor.shape[0]):
            coor = [int(x_coor[i]),int(y_coor[i]),int(z_coor[i])]
            coordinates.append(coor)

        cpy = coordinates[:]

        for p in coordinates:
            cpy.remove(p)
            for points in cpy:
                pr = [p,points]
                pairs.append(pr)

        distances = np.zeros(len(pairs))
        i = 0
    #     print(&#39;Number of pairs is {}&#39;.format(len(pairs)))
        for pair in pairs:
            p_1 = pair[0]
            p_2 = pair[1]
            distances[i] = math.sqrt(((p_1[0] - p_2[0])*spacing[0])**2 + ((p_1[1] - p_2[1])*spacing[0])**2 + ((p_1[2] - p_2[2])*spacing[1])**2)
            i = i+1
        max_dis = float(distances.max())
        max_p = np.where(distances==distances.max())[0]
        max_pints = []
        for p in max_p:
            max_pints.append(pairs[p])
        return max_dis, max_pints
    
    
    
class process:
    &#34;&#34;&#34;
    A class to represent process.

    ...

    Attributes
    ----------
    name : None
    

    Methods
    -------
    
    volumeCalculator(slices,spacing):
        Returns the volume of an object in 3D binary mask in physical measurements.
    
    getNormalized(scan,wc ,wl):
        Returns the normalized volume.

    windowing(self, scan,window_mode, window):
        apply window function on the scan
    &#34;&#34;&#34;



    def __init__(self):
        &#34;&#34;&#34;
        Constructs all the necessary attributes for the diplay object.

        Parameters
        ----------
            name : None
            
        &#34;&#34;&#34;

        self.segmentation =segmentation()   
    
    def volumeCalculator(self,slices,spacing):
        &#34;&#34;&#34;
        Returns the volume of an object in 3D binary mask in physical measurements.

        This function takes 3D binary mask, of an object as an input along with pixel spacing and returns the physical volume as an output.     The unit of volume returned is same as the unit of pixel spacing (which is usually mm).

        :param slices: Slices containing binary mask, usually of tumor. 
        :type slices: int
        :param spacing: Takes in a list of pixel spacing as [px,py,pz] where px,py and pz are pixel spacings in x,y and z cordinates. 
        :type spacing: list

        :return: Returns the physical volume
        :rtype: float
        &#34;&#34;&#34;
        #def __init__(self, spacing=[None,None,None]):
        self.spacing[0]=spacing[0]
        self.spacing[1]=spacing[1]
        self.spacing[2]=spacing[2]


        v=0

        if len(slices.shape) == 2:
            assert len(self.spacing) != 2, &#34;Spacing should have two values, spacing should be a list of two numbers in case of 2D image&#34;

            assert self.spacing[0] != None, &#34;px cannot be None&#34;
            assert self.spacing[1] != None, &#34;py cannot be None&#34;

            v = np.sum(slices)*self.spacing[0]*self.spacing[1]
        else:
            assert len(self.spacing) == 3, &#34;pz should be defined&#34;

            assert self.spacing[0] != None, &#34;px cannot be None&#34;
            assert self.spacing[1] != None, &#34;py cannot be None&#34;
            assert self.spacing[2] != None, &#34;pz cannot be None&#34;
            for i in range(slices.shape[-1]):
                v=np.sum(slices)*self.spacing[2]*self.spacing[0]*self.spacing[1]

        return v
    
    def windowing(self, scan,window_mode, window):
        &#34;&#34;&#34;
        apply window function on the scan
        
        :param scan: input scan to be performed windowing on.
        :type number: pydicom.dataset.FileDataset
    
        :return: The result of windowing.
        :rtype: numpy.ndarray
        &#34;&#34;&#34;
        assert window_mode==&#39;min/max&#39; or window_mode==&#39;wl/ww&#39; or window_mode==&#39;scan_min/scan_max&#39;, &#34;window_mode should be defined!&#34;
        assert len(window)==2, &#34;Please define min/max or ww/wl values for windowing!&#34;
    
        import numpy as np
        if window_mode==&#39;wl/ww&#39;:
            assert window[0]!=None and self.window[1]!=None, &#34;WW/WL values cannot be None!&#34; 
            wl=self.window[0]
            ww=self.window[1]
            mn = wl - ww/2
            mx = wl + ww/2
        elif self.window_mode==&#39;min/max&#39;:
            assert self.window[0]!=None and self.window[1]!=None, &#34;Min/max values cannot be None!&#34;
            mn=self.window[0]
            mx=self.window[1]
        elif self.window_mode==&#39;scan_min/scan_max&#39;:
            mn = np.amin(scan)
            mx = np.amax(scan)
        
        d = mx - mn
        scan  = np.where(scan&lt;mn,mn, scan)
        scan  = np.where(scan&gt;mx,mx, scan)
        scan = (scan-mn)/d
        return scan
        


    def getNormalized(self,scan,wc ,wl):
        &#34;&#34;&#34;
        Returns the normalized volume.

        :param scan: 3D image to normalize. 
        :type nscan: int/float
        &#34;&#34;&#34;
        mn = wc - wl
        mx = wc+wl
        d = mx - mn
        scan  = np.where(scan&lt;mn,mn, scan)
        scan  = np.where(scan&gt;mx,mx, scan)
        scan = (scan-mn)/d
        return scan 

    def resize3D(self, nscan,shape):
        &#34;&#34;&#34;
        Returns the 3D volume after resizing it to the required shape.

        :param nscan: 3D image to resize. 
        :type nscan: int/float
        &#34;&#34;&#34;
        
        from scipy import ndimage
        assert len(shape)==3,&#34;The new shape should have 3 values&#34;
        assert len(shape)==3, &#34;Image should have 3 dimensions, given &#34;+str(len(nscan.shape))+ &#34; dimensions&#34;
        depth_factor=shape[0]/nscan.shape[0]
        width_factor=shape[2]/nscan.shape[2]
        height_factor=shape[1]/nscan.shape[1]

        if mask==False:
            nscan = ndimage.zoom(nscan, (depth_factor, height_factor, width_factor), order=1)
        elif is_mask==True:
            nscan = ndimage.zoom(nscan, (depth_factor, height_factor, width_factor), order=1, mode = &#39;nearest&#39; )
    
    
        return nscan
        

class segmentation:
    &#34;&#34;&#34;&#34;

    Attributes
    ----------
    name : None
    

    Methods
    -------
    
    generic_window(ds):
        
    boneSeg(scan,wc ,wl):
      
    seg():
        &#34;&#34;&#34;
   
    
    def __init__(self, path):
        self.path=path
        
    def genericWindow(self,ds):
        
        def get_normalized(scan,wc ,wl):
            mn = wc - wl
            mx = wc+wl
            d = mx - mn
            scan  = np.where(scan&lt;mn,mn, scan)
            scan  = np.where(scan&gt;mx,mx, scan)
            scan = (scan-mn)/d
            return scan  
        
        wc= ds[0x28,0x1050].value  #window center
        w=(ds[0x28,0x1051].value) #window width
        ww=int(w/2)
       
        new_wc=wc+(0.3*wc)
        new_ww=(0.8*ww)   
        
        img=ds.pixel_array
        result=get_normalized(img,wc+(0.3*wc),(0.8*ww) )
     
        return result
    
    def boneSeg(self,ds):
    
        def normal(un):
            mn = np.amin(un)
            mx = np.amax(un)
            d = mx - mn
            normalized = (un-mn)/d
            return normalized
        
        def get_normalized(scan):
            wc= (300-(-1000))/(1000-(-1000)) #normalizing WC
            w= (1000-(-1000))/(1000-(-1000))  #normalizing WW
            wl=w/2
            mn = wc - wl
            mx = wc+wl
            d = mx - mn
            scan  = np.where(scan&lt;mn,mn, scan)
            scan  = np.where(scan&gt;mx,mx, scan)
            scan = (scan-mn)/d
            return scan        

        img=ds.pixel_array
        normal_img=normal(img)
        final_image=get_normalized(normal_img)

        return final_image     
    
    def seg(self):
        
        import pydicom
        ds=pydicom.dcmread(self.path)
        #img=ds.pixel_array
        try: 
            wc= ds[0x28,0x1050].value  #window center
            w=ds[0x28,0x1051].value #window width
            res = self.generic_window(ds)
        except:
            res = self.bone_seg(ds)
        
        return res
    
    
class Image_class:
    &#34;&#34;&#34;
    A class to represent Image.

    ...

    Attributes
    ----------
    name : None
    

    Methods
    -------
    info(additional=&#34;&#34;):
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;
        Constructs all the necessary attributes for the diplay object.

        Parameters
        ----------
            name : None
            
        &#34;&#34;&#34;

        
        self.calculate = self.calculate_class()
        self.save = self.save_class()
        self.MIP = self.MIP_class()
    
    class calculate_class:
        def __init__(self):
            pass
        def max_diameter_2D(self,mask,p_x, p_y ,arrow = False):
            &#39;&#39;&#39; 
            This function finds the maximum diameter of objects in binary mask image. 
            If arrow is True, an arrow will be drawn to show the direction of the max diameter. 
            
            
            Parameters:
                mask  :  
                p_x : 
                p_y :
                

            Returns:
                dist : 
                        
            &#39;&#39;&#39;
            
            res0 = cv2.cvtColor(mask.astype(np.uint8),cv2.COLOR_GRAY2RGB)
            res0 = np.where(res0&gt;0,255,0)
            mask = np.where(mask&gt;0,1,0)
            mask, num_lab = ndimage.label(mask)
            
            
            dist = []
            for i in range(num_lab):
                points = np.argwhere(mask==i+1)
                points = points[points[:,0].argsort()]
                distances = distance.cdist(points,points)
                if len(distances)&gt;1:
                    [p1,p2] = np.squeeze(np.where(distances == np.max(distances)))
                    if isinstance(p1, np.ndarray): 
                        p1 = p1[-1]
                    if isinstance(p2, np.ndarray): 
                        p2 = p2[-1]
                    [ty,tx] = points[p1]
                    [cy,cx] = points[p2]
                    d = (math.sqrt((((ty-cy)*p_y)**2)+(((tx-cx)*p_x)**2)))
                    dist.append(d)
                else:
                    dist.append(&#39;none&#39;)
                if arrow==True:
                    
                    res0 = cv2.arrowedLine(res0.astype(np.uint8), (cx,cy), (tx,ty),(0,0,255),2)
                    return dist,res0
                else:
                    return dist
        
        
        def max_diameter_3D(self,full_mask,spacing):
            &#39;&#39;&#39;
            This function finds the max diameter of 3D object
            Ful mask means that it should contain all the slices of nodule, so shape can be like [6,45,45] where &#39;6&#39; is number of slices
            spacing is array contains spacing of x,y and z axis, shape should be like [0.7,1.5]
            
            Parameters:
                full_mask  :  
                spacing : pixel spacing
                

            Returns:
                dist : 
                        
            &#39;&#39;&#39;
        
            # Ful mask means that it should contain all the slices of nodule, so shape can be like [6,45,45]
            # spacing is array contains spacing of x,y and z axis, shape should be like [0.7,1.5]

  
            all_points = np.where(full_mask&gt;0)
            x_coor = all_points[1]
            y_coor = all_points[2]
            z_coor = all_points[0]

            pairs = []
            coordinates = []

            for i in range(z_coor.shape[0]):
                coor = [int(x_coor[i]),int(y_coor[i]),int(z_coor[i])]
                coordinates.append(coor)

            cpy = coordinates[:]

            for p in coordinates:
                cpy.remove(p)
                for points in cpy:
                    pr = [p,points]
                    pairs.append(pr)

            distances = np.zeros(len(pairs))
            i = 0
            for pair in pairs:
                p_1 = pair[0]
                p_2 = pair[1]
                distances[i] = math.sqrt(((p_1[0] - p_2[0])*spacing[0])**2 + ((p_1[1] - p_2[1])*spacing[0])**2 + ((p_1[2] - p_2[2])*spacing[1])**2)
                i = i+1
            max_dis = float(distances.max())
            return max_dis
        
        
        def volume_3D(self,slices,spacing):
            &#39;&#39;&#39;
            This function calculates the 3D volume of an object mask. The mask should have the format axial,coronal,sagittal
            The pixel spacing is z,y,x
            Parameters:
                slices  :  
                spacing : pixel spacing
                

            Returns:
                dist : 
                        
            &#39;&#39;&#39;
        
            slices = np.where(slices&gt;0,1,0)
            v = 0
            if len(slices.shape) != 3:
                v = np.sum(slices)*spacing[0]*spacing[1]
            else:
                p = np.argwhere(slices&gt;0)
                p = np.amin(p[:,0])
                for i in range(p,slices.shape[0],1):
                    a = np.sum(slices[i,:,:])*spacing[1]*spacing[2]
                    v = v + a
            #         print(&#39;slice no.{i}&#39;.format)
                    if a==0:
                        print(&#39;Done&#39;)
                        break;
            return v
        
        def maxNodule(self,mask_scan):
            &#39;&#39;&#39;
            Depending on the intensities,
            this function will only return the nodule which is enhanced and more visible in the scans and
            remove the other nodules function saves 2D images with accordance with types with the types
            
            Parameters:
                    scan :  
                    mask :


                Returns:
                    processed mask : 
            &#39;&#39;&#39;

            labelled_mask, num_labels = skimage.measure.label(mask_scan)
            mask_scan = np.zeros(mask_scan.shape)
            for j in range(1,num_labels+1):
                mask2 =labelled_mask_scan.copy()
                mask2[mask2!=j]=0
                mask2[mask2==j]=1
                if(np.sum(mask2)&gt;np.sum(mask_scan)):
                    mask_scan = mask2
            return(mask_scan)

    class save_class:
        &#39;&#39;&#39;
        This function saves 2D images with accordance with types with the types
        Parameters:
                image  :  
                path :
                

            Returns:
                image : 
                        
            
        
        &#39;&#39;&#39;
        def __init__(self):
            pass
        def as_png(self,image, path):
            if len(image.shape)&lt;3:
                image = cv2.cvtColor(image.astype(np.uint8),cv2.COLOR_GRAY2RGB)
            cv2.imwrite((path + &#34;.png&#34;),image)
            
        def as_jpeg(self,image, path):
            if len(image.shape)&lt;3:
                image = cv2.cvtColor(image.astype(np.uint8),cv2.COLOR_GRAY2RGB)
            cv2.imwrite((path + &#34;.jpeg&#34;),image)
            
        def as_bmp(self,image, path):
            if len(image.shape)&lt;3:
                image = cv2.cvtColor(image.astype(np.uint8),cv2.COLOR_GRAY2RGB)
            image = Image.fromarray(image)
            image.save(path + &#34;.bmp&#34;)
            
        def as_pdf(self,image, path):
            if len(image.shape)&lt;3:
                image = cv2.cvtColor(image.astype(np.uint8),cv2.COLOR_GRAY2RGB)
            image = Image.fromarray(image)
            image.save(path + &#34;.pdf&#34;)
    
    class MIP_class:
        &#39;&#39;&#39;
        This class generates Maximum Intensity Projections along the given directions
        Parameters:
                image  :  
                path :
                

            Returns:
                image : 
                        
                       
        
        &#39;&#39;&#39;
        
        def axial(self,scan):
            image = np.amax(scan, axis = 0)
            return(image)
        def sagittal_left(self,scan):
            scan = np.array(scan)
            image = np.amax(scan[:,:,round(scan.shape[2]/2):], axis = 2)
            return(image)
        def sagittal_right(self,scan):
            scan = np.array(scan)
            image = np.amax(scan[:,:,:round(scan.shape[2]/2)], axis = 2)
            return(image)
        def sagittal(self,scan):
            scan = np.array(scan)
            image = np.amax(scan, axis = 2)
            return(image)
        def coronal(slf, scan):
            scan = np.array(scan)
            image = np.amax(scan, axis = 1)
            return(image)
    
    def mask_overlay(self, img, mask, mode = &#39;axial&#39;):
        &#39;&#39;&#39;
        This function overlays the mask on the scan with a MIP in the provided direction: axial, coronal or sagittal
        Parameters:
                image  :  
                mask :
                mode :
                

            Returns:
                image : 
                        
                       
        
        &#39;&#39;&#39;
       
        
        if mode == &#39;coronal&#39;:
            ax = 1
        elif mode ==&#39;axial&#39;:
            ax = 0
        else:
            ax = 2
        s = img
        s_mips = np.amax(s, axis= ax)
        mini = np.amin(s_mips)
        maxi = np.amax(s_mips)
        d = maxi - mini
        s_mips = (s_mips - mini)/d
        m = copy.copy(mask)
        m_mips = np.amax(m, axis= ax)
        con_ones = m_mips
        overlayed = copy.copy(m_mips)
        con_zeros = 1 - con_ones

        RGB_img = np.zeros([s_mips.shape[0],s_mips.shape[1],3],int)
        RGB_img[:,:,0] = s_mips*con_zeros*255 + overlayed*255
        RGB_img[:,:,2] = s_mips*con_zeros*255 
        RGB_img[:,:,1] = s_mips*con_zeros*255  
        
        return RGB_img
        
        
            
    
class CV:
    &#34;&#34;&#34;
    A class to represent Computervision.

    ...

    Attributes
    ----------
    name : None
    

    Methods
    -------
    EdgeDetection(img_path):
        Takes in an Image path,displays the edges of the image 
    
    ImageSegmentation(img_path): 
        Image segmentation using K-Means takes input as image path and displays segmentation of image
    
    TemplateMatching(img_path,temp_path):
        It simply slides the template image over the input
        image (as in 2D convolution) and compares the template and patch of input image under the template image.
     
     BlobDetector(img_path):
        Takes in an image path and Draw detected blobs as blue circles
    
    OpticalFlow(video_path):
        Optical flow is the motion of objects between the consecutive frames of the sequence, 
        caused by the relative motion between the camera and the object.
        It takes motion video as input in avi format and detects Moving objects
        
        

    &#34;&#34;&#34;

    def __init__(self):
                
        &#34;&#34;&#34;
        Constructs all the necessary attributes for the diplay object.

        Parameters
        ----------
            name : None
            
        &#34;&#34;&#34;
        pass
    

    def EdgeDetection(self, img_path):
        &#39;&#39;&#39;Takes in an Image path,displays the edges of the image
         Parameters:
                img_path  :  path of the image
               

        Returns:
                edges : Plot the edges in image 
                        
        &#39;&#39;&#39;
        img = cv2.imread(img_path)

        gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        print(gray_img.shape)

        # applying canny edge transformations
        edges = cv2.Canny(gray_img, threshold1=30, threshold2=100)

            # showing the output frame
        plt.imshow(edges,&#39;gray&#39;)
        
    def ImageSegmentation(self,img_path): 
        &#39;&#39;&#39;Image segmentation using K-Means takes input as image path and displays segmentation of image
         Parameters:
                img_path  :  path of the image
               

        Returns:
                image segmentation : Plot the segmented image
                        
        &#39;&#39;&#39;
        img = cv2.imread(img_path)
            # reshape the image to a 2D array of pixels and 3 array values
        pixels_values = img.reshape((-1, 3))

        # conerting to float32
        pixels_values = np.float32(pixels_values)

        criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 100, 0.2)

        # Number of clusters]
        K = 3

        _, labels, (centers) = cv2.kmeans(pixels_values,
                                          K=K,
                                          bestLabels=None,
                                          criteria=criteria,
                                          attempts=10,
                                          flags=cv2.KMEANS_RANDOM_CENTERS)

        # converting to 8 bit values
        centers = np.uint8(centers)

        # flatten the labels array
        labels = labels.flatten()

        # convert all pixels to the color of the centroids
        segmented_image = centers[labels]

        segmented_image = segmented_image.reshape(img.shape)
        plt.imshow(segmented_image)
        
    def TemplateMatching(self,img_path,temp_path):
        &#39;&#39;&#39;&#39;
        It simply slides the template image over the input
        image (as in 2D convolution) and compares the template and patch of input image under the template image.

         Parameters:
                img_path  :  path of the image
                temp_path : path of template image
               

        Returns:
                image  : Plot the template matching image
                        
        &#39;&#39;&#39;
        
        img = cv2.imread(img_path)
        temp = cv2.imread(temp_path, 0)


        source_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        
        w,h = temp.shape[::-1]

        res = cv2.matchTemplate(source_gray, temp, cv2.TM_CCOEFF_NORMED)
        threshold = 0.2
        loc = np.where(res &gt;= threshold)

        print(*loc)
        for port in zip(*loc[::-1]):
            a=cv2.rectangle(img, port,(port[0] + w, port[1] + h), (0, 255, 255), 2)


        plt.imshow(a)
        
    def BlobDetector(self,img_path):
        &#39;&#39;&#39; Takes in an image path and Draw detected blobs as blue circles
        Parameters:
                img_path  :  path of the image
               

        Returns:
                Blobs : Plot the blobs detected in image
                        
        &#39;&#39;&#39;
        img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)

        # Set up the blob detector
        detector = cv2.SimpleBlobDetector_create()

        # Detect blobs from the image.
        keypoints = detector.detect(img)

        # Draw detected blobs as red circles.
        # cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS - This method draws detected blobs as red circles and ensures that the size of the circle corresponds to the size of the blob.
        blobs = cv2.drawKeypoints(img, keypoints, np.array([]), (0,0,255), cv2.DRAW_MATCHES_FLAGS_DEFAULT)

        plt.imshow(blobs)
        
    def OpticalFlow(self,video_path):
        &#39;&#39;&#39;
        Optical flow is the motion of objects between the consecutive frames of the sequence, 
        caused by the relative motion between the camera and the object.
        It takes motion video as input in avi format and detects Moving objects
        Parameters:
                video_path  :  path of the motion video
               

        Returns:
                images : Plot the points on image with relative motion between the consecutive frames of the sequence
                        
        &#39;&#39;&#39;
        
        cap = cv2.VideoCapture(video_path)

        ret, frame = cap.read()
        gs_im0 = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        points_prev = cv2.goodFeaturesToTrack(gs_im0, 100, 0.03, 9.0, False)

        while(cap.isOpened()):
            ret, frame = cap.read()
            if ret==True:
            #is_empty = frame.size == 0

            #print(is_empty)

                gs_im1 = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)


                # Call tracker.
                points, st, err = cv2.calcOpticalFlowPyrLK(gs_im0, gs_im1, points_prev, None, (3,3))
                #print(points)
                for i,p in enumerate(points):
                    a,b = p.ravel()
                    frame = cv2.circle(frame,(int(a),int(b)),3,(255,255,255),-1)

                plt.imshow(frame)
                plt.show()
                points_prev = points
                gs_im0 = gs_im1


            else:
                break
               # print(frame)

        




        
        </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Healthhub.healthhub.CV"><code class="flex name class">
<span>class <span class="ident">CV</span></span>
</code></dt>
<dd>
<div class="desc"><p>A class to represent Computervision.</p>
<p>&hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>EdgeDetection(img_path):
Takes in an Image path,displays the edges of the image </p>
<p>ImageSegmentation(img_path):
Image segmentation using K-Means takes input as image path and displays segmentation of image</p>
<p>TemplateMatching(img_path,temp_path):
It simply slides the template image over the input
image (as in 2D convolution) and compares the template and patch of input image under the template image.</p>
<p>BlobDetector(img_path):
Takes in an image path and Draw detected blobs as blue circles</p>
<p>OpticalFlow(video_path):
Optical flow is the motion of objects between the consecutive frames of the sequence,
caused by the relative motion between the camera and the object.
It takes motion video as input in avi format and detects Moving objects</p>
<p>Constructs all the necessary attributes for the diplay object.</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name : None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CV:
    &#34;&#34;&#34;
    A class to represent Computervision.

    ...

    Attributes
    ----------
    name : None
    

    Methods
    -------
    EdgeDetection(img_path):
        Takes in an Image path,displays the edges of the image 
    
    ImageSegmentation(img_path): 
        Image segmentation using K-Means takes input as image path and displays segmentation of image
    
    TemplateMatching(img_path,temp_path):
        It simply slides the template image over the input
        image (as in 2D convolution) and compares the template and patch of input image under the template image.
     
     BlobDetector(img_path):
        Takes in an image path and Draw detected blobs as blue circles
    
    OpticalFlow(video_path):
        Optical flow is the motion of objects between the consecutive frames of the sequence, 
        caused by the relative motion between the camera and the object.
        It takes motion video as input in avi format and detects Moving objects
        
        

    &#34;&#34;&#34;

    def __init__(self):
                
        &#34;&#34;&#34;
        Constructs all the necessary attributes for the diplay object.

        Parameters
        ----------
            name : None
            
        &#34;&#34;&#34;
        pass
    

    def EdgeDetection(self, img_path):
        &#39;&#39;&#39;Takes in an Image path,displays the edges of the image
         Parameters:
                img_path  :  path of the image
               

        Returns:
                edges : Plot the edges in image 
                        
        &#39;&#39;&#39;
        img = cv2.imread(img_path)

        gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        print(gray_img.shape)

        # applying canny edge transformations
        edges = cv2.Canny(gray_img, threshold1=30, threshold2=100)

            # showing the output frame
        plt.imshow(edges,&#39;gray&#39;)
        
    def ImageSegmentation(self,img_path): 
        &#39;&#39;&#39;Image segmentation using K-Means takes input as image path and displays segmentation of image
         Parameters:
                img_path  :  path of the image
               

        Returns:
                image segmentation : Plot the segmented image
                        
        &#39;&#39;&#39;
        img = cv2.imread(img_path)
            # reshape the image to a 2D array of pixels and 3 array values
        pixels_values = img.reshape((-1, 3))

        # conerting to float32
        pixels_values = np.float32(pixels_values)

        criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 100, 0.2)

        # Number of clusters]
        K = 3

        _, labels, (centers) = cv2.kmeans(pixels_values,
                                          K=K,
                                          bestLabels=None,
                                          criteria=criteria,
                                          attempts=10,
                                          flags=cv2.KMEANS_RANDOM_CENTERS)

        # converting to 8 bit values
        centers = np.uint8(centers)

        # flatten the labels array
        labels = labels.flatten()

        # convert all pixels to the color of the centroids
        segmented_image = centers[labels]

        segmented_image = segmented_image.reshape(img.shape)
        plt.imshow(segmented_image)
        
    def TemplateMatching(self,img_path,temp_path):
        &#39;&#39;&#39;&#39;
        It simply slides the template image over the input
        image (as in 2D convolution) and compares the template and patch of input image under the template image.

         Parameters:
                img_path  :  path of the image
                temp_path : path of template image
               

        Returns:
                image  : Plot the template matching image
                        
        &#39;&#39;&#39;
        
        img = cv2.imread(img_path)
        temp = cv2.imread(temp_path, 0)


        source_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        
        w,h = temp.shape[::-1]

        res = cv2.matchTemplate(source_gray, temp, cv2.TM_CCOEFF_NORMED)
        threshold = 0.2
        loc = np.where(res &gt;= threshold)

        print(*loc)
        for port in zip(*loc[::-1]):
            a=cv2.rectangle(img, port,(port[0] + w, port[1] + h), (0, 255, 255), 2)


        plt.imshow(a)
        
    def BlobDetector(self,img_path):
        &#39;&#39;&#39; Takes in an image path and Draw detected blobs as blue circles
        Parameters:
                img_path  :  path of the image
               

        Returns:
                Blobs : Plot the blobs detected in image
                        
        &#39;&#39;&#39;
        img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)

        # Set up the blob detector
        detector = cv2.SimpleBlobDetector_create()

        # Detect blobs from the image.
        keypoints = detector.detect(img)

        # Draw detected blobs as red circles.
        # cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS - This method draws detected blobs as red circles and ensures that the size of the circle corresponds to the size of the blob.
        blobs = cv2.drawKeypoints(img, keypoints, np.array([]), (0,0,255), cv2.DRAW_MATCHES_FLAGS_DEFAULT)

        plt.imshow(blobs)
        
    def OpticalFlow(self,video_path):
        &#39;&#39;&#39;
        Optical flow is the motion of objects between the consecutive frames of the sequence, 
        caused by the relative motion between the camera and the object.
        It takes motion video as input in avi format and detects Moving objects
        Parameters:
                video_path  :  path of the motion video
               

        Returns:
                images : Plot the points on image with relative motion between the consecutive frames of the sequence
                        
        &#39;&#39;&#39;
        
        cap = cv2.VideoCapture(video_path)

        ret, frame = cap.read()
        gs_im0 = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
        points_prev = cv2.goodFeaturesToTrack(gs_im0, 100, 0.03, 9.0, False)

        while(cap.isOpened()):
            ret, frame = cap.read()
            if ret==True:
            #is_empty = frame.size == 0

            #print(is_empty)

                gs_im1 = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)


                # Call tracker.
                points, st, err = cv2.calcOpticalFlowPyrLK(gs_im0, gs_im1, points_prev, None, (3,3))
                #print(points)
                for i,p in enumerate(points):
                    a,b = p.ravel()
                    frame = cv2.circle(frame,(int(a),int(b)),3,(255,255,255),-1)

                plt.imshow(frame)
                plt.show()
                points_prev = points
                gs_im0 = gs_im1


            else:
                break</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="Healthhub.healthhub.CV.BlobDetector"><code class="name flex">
<span>def <span class="ident">BlobDetector</span></span>(<span>self, img_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes in an image path and Draw detected blobs as blue circles</p>
<h2 id="parameters">Parameters</h2>
<p>img_path
:
path of the image</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Blobs </code></dt>
<dd>Plot the blobs detected in image</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BlobDetector(self,img_path):
    &#39;&#39;&#39; Takes in an image path and Draw detected blobs as blue circles
    Parameters:
            img_path  :  path of the image
           

    Returns:
            Blobs : Plot the blobs detected in image
                    
    &#39;&#39;&#39;
    img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)

    # Set up the blob detector
    detector = cv2.SimpleBlobDetector_create()

    # Detect blobs from the image.
    keypoints = detector.detect(img)

    # Draw detected blobs as red circles.
    # cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS - This method draws detected blobs as red circles and ensures that the size of the circle corresponds to the size of the blob.
    blobs = cv2.drawKeypoints(img, keypoints, np.array([]), (0,0,255), cv2.DRAW_MATCHES_FLAGS_DEFAULT)

    plt.imshow(blobs)</code></pre>
</details>
</dd>
<dt id="Healthhub.healthhub.CV.EdgeDetection"><code class="name flex">
<span>def <span class="ident">EdgeDetection</span></span>(<span>self, img_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes in an Image path,displays the edges of the image
Parameters:
img_path
:
path of the image</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>edges </code></dt>
<dd>Plot the edges in image</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def EdgeDetection(self, img_path):
    &#39;&#39;&#39;Takes in an Image path,displays the edges of the image
     Parameters:
            img_path  :  path of the image
           

    Returns:
            edges : Plot the edges in image 
                    
    &#39;&#39;&#39;
    img = cv2.imread(img_path)

    gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    print(gray_img.shape)

    # applying canny edge transformations
    edges = cv2.Canny(gray_img, threshold1=30, threshold2=100)

        # showing the output frame
    plt.imshow(edges,&#39;gray&#39;)</code></pre>
</details>
</dd>
<dt id="Healthhub.healthhub.CV.ImageSegmentation"><code class="name flex">
<span>def <span class="ident">ImageSegmentation</span></span>(<span>self, img_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Image segmentation using K-Means takes input as image path and displays segmentation of image
Parameters:
img_path
:
path of the image</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>image <a title="Healthhub.healthhub.segmentation" href="#Healthhub.healthhub.segmentation">segmentation</a> </code></dt>
<dd>Plot the segmented image</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ImageSegmentation(self,img_path): 
    &#39;&#39;&#39;Image segmentation using K-Means takes input as image path and displays segmentation of image
     Parameters:
            img_path  :  path of the image
           

    Returns:
            image segmentation : Plot the segmented image
                    
    &#39;&#39;&#39;
    img = cv2.imread(img_path)
        # reshape the image to a 2D array of pixels and 3 array values
    pixels_values = img.reshape((-1, 3))

    # conerting to float32
    pixels_values = np.float32(pixels_values)

    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 100, 0.2)

    # Number of clusters]
    K = 3

    _, labels, (centers) = cv2.kmeans(pixels_values,
                                      K=K,
                                      bestLabels=None,
                                      criteria=criteria,
                                      attempts=10,
                                      flags=cv2.KMEANS_RANDOM_CENTERS)

    # converting to 8 bit values
    centers = np.uint8(centers)

    # flatten the labels array
    labels = labels.flatten()

    # convert all pixels to the color of the centroids
    segmented_image = centers[labels]

    segmented_image = segmented_image.reshape(img.shape)
    plt.imshow(segmented_image)</code></pre>
</details>
</dd>
<dt id="Healthhub.healthhub.CV.OpticalFlow"><code class="name flex">
<span>def <span class="ident">OpticalFlow</span></span>(<span>self, video_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Optical flow is the motion of objects between the consecutive frames of the sequence,
caused by the relative motion between the camera and the object.
It takes motion video as input in avi format and detects Moving objects</p>
<h2 id="parameters">Parameters</h2>
<p>video_path
:
path of the motion video</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>images </code></dt>
<dd>Plot the points on image with relative motion between the consecutive frames of the sequence</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def OpticalFlow(self,video_path):
    &#39;&#39;&#39;
    Optical flow is the motion of objects between the consecutive frames of the sequence, 
    caused by the relative motion between the camera and the object.
    It takes motion video as input in avi format and detects Moving objects
    Parameters:
            video_path  :  path of the motion video
           

    Returns:
            images : Plot the points on image with relative motion between the consecutive frames of the sequence
                    
    &#39;&#39;&#39;
    
    cap = cv2.VideoCapture(video_path)

    ret, frame = cap.read()
    gs_im0 = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    points_prev = cv2.goodFeaturesToTrack(gs_im0, 100, 0.03, 9.0, False)

    while(cap.isOpened()):
        ret, frame = cap.read()
        if ret==True:
        #is_empty = frame.size == 0

        #print(is_empty)

            gs_im1 = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)


            # Call tracker.
            points, st, err = cv2.calcOpticalFlowPyrLK(gs_im0, gs_im1, points_prev, None, (3,3))
            #print(points)
            for i,p in enumerate(points):
                a,b = p.ravel()
                frame = cv2.circle(frame,(int(a),int(b)),3,(255,255,255),-1)

            plt.imshow(frame)
            plt.show()
            points_prev = points
            gs_im0 = gs_im1


        else:
            break</code></pre>
</details>
</dd>
<dt id="Healthhub.healthhub.CV.TemplateMatching"><code class="name flex">
<span>def <span class="ident">TemplateMatching</span></span>(<span>self, img_path, temp_path)</span>
</code></dt>
<dd>
<div class="desc"><p>'
It simply slides the template image over the input
image (as in 2D convolution) and compares the template and patch of input image under the template image.</p>
<p>Parameters:
img_path
:
path of the image
temp_path : path of template image</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>image
</code></dt>
<dd>Plot the template matching image</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def TemplateMatching(self,img_path,temp_path):
    &#39;&#39;&#39;&#39;
    It simply slides the template image over the input
    image (as in 2D convolution) and compares the template and patch of input image under the template image.

     Parameters:
            img_path  :  path of the image
            temp_path : path of template image
           

    Returns:
            image  : Plot the template matching image
                    
    &#39;&#39;&#39;
    
    img = cv2.imread(img_path)
    temp = cv2.imread(temp_path, 0)


    source_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    
    w,h = temp.shape[::-1]

    res = cv2.matchTemplate(source_gray, temp, cv2.TM_CCOEFF_NORMED)
    threshold = 0.2
    loc = np.where(res &gt;= threshold)

    print(*loc)
    for port in zip(*loc[::-1]):
        a=cv2.rectangle(img, port,(port[0] + w, port[1] + h), (0, 255, 255), 2)


    plt.imshow(a)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Healthhub.healthhub.Image_class"><code class="flex name class">
<span>class <span class="ident">Image_class</span></span>
</code></dt>
<dd>
<div class="desc"><p>A class to represent Image.</p>
<p>&hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>info(additional=""):</p>
<p>Constructs all the necessary attributes for the diplay object.</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name : None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Image_class:
    &#34;&#34;&#34;
    A class to represent Image.

    ...

    Attributes
    ----------
    name : None
    

    Methods
    -------
    info(additional=&#34;&#34;):
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;
        Constructs all the necessary attributes for the diplay object.

        Parameters
        ----------
            name : None
            
        &#34;&#34;&#34;

        
        self.calculate = self.calculate_class()
        self.save = self.save_class()
        self.MIP = self.MIP_class()
    
    class calculate_class:
        def __init__(self):
            pass
        def max_diameter_2D(self,mask,p_x, p_y ,arrow = False):
            &#39;&#39;&#39; 
            This function finds the maximum diameter of objects in binary mask image. 
            If arrow is True, an arrow will be drawn to show the direction of the max diameter. 
            
            
            Parameters:
                mask  :  
                p_x : 
                p_y :
                

            Returns:
                dist : 
                        
            &#39;&#39;&#39;
            
            res0 = cv2.cvtColor(mask.astype(np.uint8),cv2.COLOR_GRAY2RGB)
            res0 = np.where(res0&gt;0,255,0)
            mask = np.where(mask&gt;0,1,0)
            mask, num_lab = ndimage.label(mask)
            
            
            dist = []
            for i in range(num_lab):
                points = np.argwhere(mask==i+1)
                points = points[points[:,0].argsort()]
                distances = distance.cdist(points,points)
                if len(distances)&gt;1:
                    [p1,p2] = np.squeeze(np.where(distances == np.max(distances)))
                    if isinstance(p1, np.ndarray): 
                        p1 = p1[-1]
                    if isinstance(p2, np.ndarray): 
                        p2 = p2[-1]
                    [ty,tx] = points[p1]
                    [cy,cx] = points[p2]
                    d = (math.sqrt((((ty-cy)*p_y)**2)+(((tx-cx)*p_x)**2)))
                    dist.append(d)
                else:
                    dist.append(&#39;none&#39;)
                if arrow==True:
                    
                    res0 = cv2.arrowedLine(res0.astype(np.uint8), (cx,cy), (tx,ty),(0,0,255),2)
                    return dist,res0
                else:
                    return dist
        
        
        def max_diameter_3D(self,full_mask,spacing):
            &#39;&#39;&#39;
            This function finds the max diameter of 3D object
            Ful mask means that it should contain all the slices of nodule, so shape can be like [6,45,45] where &#39;6&#39; is number of slices
            spacing is array contains spacing of x,y and z axis, shape should be like [0.7,1.5]
            
            Parameters:
                full_mask  :  
                spacing : pixel spacing
                

            Returns:
                dist : 
                        
            &#39;&#39;&#39;
        
            # Ful mask means that it should contain all the slices of nodule, so shape can be like [6,45,45]
            # spacing is array contains spacing of x,y and z axis, shape should be like [0.7,1.5]

  
            all_points = np.where(full_mask&gt;0)
            x_coor = all_points[1]
            y_coor = all_points[2]
            z_coor = all_points[0]

            pairs = []
            coordinates = []

            for i in range(z_coor.shape[0]):
                coor = [int(x_coor[i]),int(y_coor[i]),int(z_coor[i])]
                coordinates.append(coor)

            cpy = coordinates[:]

            for p in coordinates:
                cpy.remove(p)
                for points in cpy:
                    pr = [p,points]
                    pairs.append(pr)

            distances = np.zeros(len(pairs))
            i = 0
            for pair in pairs:
                p_1 = pair[0]
                p_2 = pair[1]
                distances[i] = math.sqrt(((p_1[0] - p_2[0])*spacing[0])**2 + ((p_1[1] - p_2[1])*spacing[0])**2 + ((p_1[2] - p_2[2])*spacing[1])**2)
                i = i+1
            max_dis = float(distances.max())
            return max_dis
        
        
        def volume_3D(self,slices,spacing):
            &#39;&#39;&#39;
            This function calculates the 3D volume of an object mask. The mask should have the format axial,coronal,sagittal
            The pixel spacing is z,y,x
            Parameters:
                slices  :  
                spacing : pixel spacing
                

            Returns:
                dist : 
                        
            &#39;&#39;&#39;
        
            slices = np.where(slices&gt;0,1,0)
            v = 0
            if len(slices.shape) != 3:
                v = np.sum(slices)*spacing[0]*spacing[1]
            else:
                p = np.argwhere(slices&gt;0)
                p = np.amin(p[:,0])
                for i in range(p,slices.shape[0],1):
                    a = np.sum(slices[i,:,:])*spacing[1]*spacing[2]
                    v = v + a
            #         print(&#39;slice no.{i}&#39;.format)
                    if a==0:
                        print(&#39;Done&#39;)
                        break;
            return v
        
        def maxNodule(self,mask_scan):
            &#39;&#39;&#39;
            Depending on the intensities,
            this function will only return the nodule which is enhanced and more visible in the scans and
            remove the other nodules function saves 2D images with accordance with types with the types
            
            Parameters:
                    scan :  
                    mask :


                Returns:
                    processed mask : 
            &#39;&#39;&#39;

            labelled_mask, num_labels = skimage.measure.label(mask_scan)
            mask_scan = np.zeros(mask_scan.shape)
            for j in range(1,num_labels+1):
                mask2 =labelled_mask_scan.copy()
                mask2[mask2!=j]=0
                mask2[mask2==j]=1
                if(np.sum(mask2)&gt;np.sum(mask_scan)):
                    mask_scan = mask2
            return(mask_scan)

    class save_class:
        &#39;&#39;&#39;
        This function saves 2D images with accordance with types with the types
        Parameters:
                image  :  
                path :
                

            Returns:
                image : 
                        
            
        
        &#39;&#39;&#39;
        def __init__(self):
            pass
        def as_png(self,image, path):
            if len(image.shape)&lt;3:
                image = cv2.cvtColor(image.astype(np.uint8),cv2.COLOR_GRAY2RGB)
            cv2.imwrite((path + &#34;.png&#34;),image)
            
        def as_jpeg(self,image, path):
            if len(image.shape)&lt;3:
                image = cv2.cvtColor(image.astype(np.uint8),cv2.COLOR_GRAY2RGB)
            cv2.imwrite((path + &#34;.jpeg&#34;),image)
            
        def as_bmp(self,image, path):
            if len(image.shape)&lt;3:
                image = cv2.cvtColor(image.astype(np.uint8),cv2.COLOR_GRAY2RGB)
            image = Image.fromarray(image)
            image.save(path + &#34;.bmp&#34;)
            
        def as_pdf(self,image, path):
            if len(image.shape)&lt;3:
                image = cv2.cvtColor(image.astype(np.uint8),cv2.COLOR_GRAY2RGB)
            image = Image.fromarray(image)
            image.save(path + &#34;.pdf&#34;)
    
    class MIP_class:
        &#39;&#39;&#39;
        This class generates Maximum Intensity Projections along the given directions
        Parameters:
                image  :  
                path :
                

            Returns:
                image : 
                        
                       
        
        &#39;&#39;&#39;
        
        def axial(self,scan):
            image = np.amax(scan, axis = 0)
            return(image)
        def sagittal_left(self,scan):
            scan = np.array(scan)
            image = np.amax(scan[:,:,round(scan.shape[2]/2):], axis = 2)
            return(image)
        def sagittal_right(self,scan):
            scan = np.array(scan)
            image = np.amax(scan[:,:,:round(scan.shape[2]/2)], axis = 2)
            return(image)
        def sagittal(self,scan):
            scan = np.array(scan)
            image = np.amax(scan, axis = 2)
            return(image)
        def coronal(slf, scan):
            scan = np.array(scan)
            image = np.amax(scan, axis = 1)
            return(image)
    
    def mask_overlay(self, img, mask, mode = &#39;axial&#39;):
        &#39;&#39;&#39;
        This function overlays the mask on the scan with a MIP in the provided direction: axial, coronal or sagittal
        Parameters:
                image  :  
                mask :
                mode :
                

            Returns:
                image : 
                        
                       
        
        &#39;&#39;&#39;
       
        
        if mode == &#39;coronal&#39;:
            ax = 1
        elif mode ==&#39;axial&#39;:
            ax = 0
        else:
            ax = 2
        s = img
        s_mips = np.amax(s, axis= ax)
        mini = np.amin(s_mips)
        maxi = np.amax(s_mips)
        d = maxi - mini
        s_mips = (s_mips - mini)/d
        m = copy.copy(mask)
        m_mips = np.amax(m, axis= ax)
        con_ones = m_mips
        overlayed = copy.copy(m_mips)
        con_zeros = 1 - con_ones

        RGB_img = np.zeros([s_mips.shape[0],s_mips.shape[1],3],int)
        RGB_img[:,:,0] = s_mips*con_zeros*255 + overlayed*255
        RGB_img[:,:,2] = s_mips*con_zeros*255 
        RGB_img[:,:,1] = s_mips*con_zeros*255  
        
        return RGB_img</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="Healthhub.healthhub.Image_class.MIP_class"><code class="name">var <span class="ident">MIP_class</span></code></dt>
<dd>
<div class="desc"><p>This class generates Maximum Intensity Projections along the given directions</p>
<h2 id="parameters">Parameters</h2>
<pre><code>image  :  
path :
</code></pre>
<p>Returns:
image :</p></div>
</dd>
<dt id="Healthhub.healthhub.Image_class.calculate_class"><code class="name">var <span class="ident">calculate_class</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="Healthhub.healthhub.Image_class.save_class"><code class="name">var <span class="ident">save_class</span></code></dt>
<dd>
<div class="desc"><p>This function saves 2D images with accordance with types with the types</p>
<h2 id="parameters">Parameters</h2>
<pre><code>image  :  
path :
</code></pre>
<p>Returns:
image :</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Healthhub.healthhub.Image_class.mask_overlay"><code class="name flex">
<span>def <span class="ident">mask_overlay</span></span>(<span>self, img, mask, mode='axial')</span>
</code></dt>
<dd>
<div class="desc"><p>This function overlays the mask on the scan with a MIP in the provided direction: axial, coronal or sagittal</p>
<h2 id="parameters">Parameters</h2>
<pre><code>image  :  
mask :
mode :
</code></pre>
<p>Returns:
image :</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mask_overlay(self, img, mask, mode = &#39;axial&#39;):
    &#39;&#39;&#39;
    This function overlays the mask on the scan with a MIP in the provided direction: axial, coronal or sagittal
    Parameters:
            image  :  
            mask :
            mode :
            

        Returns:
            image : 
                    
                   
    
    &#39;&#39;&#39;
   
    
    if mode == &#39;coronal&#39;:
        ax = 1
    elif mode ==&#39;axial&#39;:
        ax = 0
    else:
        ax = 2
    s = img
    s_mips = np.amax(s, axis= ax)
    mini = np.amin(s_mips)
    maxi = np.amax(s_mips)
    d = maxi - mini
    s_mips = (s_mips - mini)/d
    m = copy.copy(mask)
    m_mips = np.amax(m, axis= ax)
    con_ones = m_mips
    overlayed = copy.copy(m_mips)
    con_zeros = 1 - con_ones

    RGB_img = np.zeros([s_mips.shape[0],s_mips.shape[1],3],int)
    RGB_img[:,:,0] = s_mips*con_zeros*255 + overlayed*255
    RGB_img[:,:,2] = s_mips*con_zeros*255 
    RGB_img[:,:,1] = s_mips*con_zeros*255  
    
    return RGB_img</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Healthhub.healthhub.dicom"><code class="flex name class">
<span>class <span class="ident">dicom</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class dicom:

    def __init__(self):
        self.read=read()
        self.modify=modify()
        self.display=display()</code></pre>
</details>
</dd>
<dt id="Healthhub.healthhub.display"><code class="flex name class">
<span>class <span class="ident">display</span></span>
</code></dt>
<dd>
<div class="desc"><p>A class to represent display.</p>
<p>&hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>volume</code></dt>
<dd>3d volume array</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>multipleSlice(volume):
Plot the multiple slices of a given volume</p>
<p>plotSlice(image):
Plots the 2D plot of given slice image
</p>
<p>display3D(volume):
Plots the 3D plot given numpy array</p>
<p>intensityHist(array):
it will plot intensity histogram of given array
</p>
<p>Constructs all the necessary attributes for the diplay object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class display:
    &#34;&#34;&#34;
    A class to represent display.

    ...

    Attributes
    ----------
    name : volume
        3d volume array
    

    Methods
    -------
    multipleSlice(volume):
        Plot the multiple slices of a given volume
    
    plotSlice(image):
        Plots the 2D plot of given slice image  
    
    display3D(volume):
        Plots the 3D plot given numpy array
    
    intensityHist(array):
        it will plot intensity histogram of given array        
           
    
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;
        Constructs all the necessary attributes for the diplay object.
        &#34;&#34;&#34;

        pass
        
    def multipleSlice(self,volume):
        &#39;&#39;&#39;
        allows the user to navigate through different slices by using a slider widget
        
        Parameters:
        volume (int)(float): A 3d numpy array

        Returns:
                Mutiple slices (int)(float): axial , coronal and sagittal slices 
        &#39;&#39;&#39;

        figsize = (100,100)
        cmap = &#39;gray&#39;
        v = [np.min(volume), np.max(volume)] 

        def views():
            def plot_slice(z1, z2, z3):
                # Plot slice for the given plane and slice
                f,ax = plt.subplots(1,3, figsize=figsize)
                #print(self.figsize)
                #self.fig = plt.figure(figsize=self.figsize)
                #f(figsize = self.figsize)
                ax[0].imshow(vol1[:,:,z1], cmap=plt.get_cmap(cmap), 
                    vmin=v[0], vmax=v[1])
                ax[1].imshow(vol2[:,:,z2], cmap=plt.get_cmap(cmap), 
                    vmin=v[0], vmax=v[1])
                ax[2].imshow(vol3[:,:,z3], cmap=plt.get_cmap(cmap), 
                    vmin=v[0], vmax=v[1])
                plt.show()

            vol1 = np.transpose(volume, [1,2,0])
            vol2 = np.rot90(np.transpose(volume, [2,0,1]), 3) #rotate 270 degrees
            vol3 = np.transpose(volume, [0,1,2])
            maxZ1 = vol1.shape[2] - 1
            maxZ2 = vol2.shape[2] - 1
            maxZ3 = vol3.shape[2] - 1
            ipyw.interact(plot_slice, 
                z1=ipyw.IntSlider(min=0, max=maxZ1, step=1, continuous_update=False, 
                description=&#39;Axial:&#39;), 
                z2=ipyw.IntSlider(min=0, max=maxZ2, step=1, continuous_update=False, 
                description=&#39;Coronal:&#39;),
                z3=ipyw.IntSlider(min=0, max=maxZ3, step=1, continuous_update=False, 
            description=&#39;Sagittal:&#39;))

        ipyw.interact(views)

    def plotSlice(self, image):
        &#39;&#39;&#39;
        Returns the 2D plot of given slice image        
        Parameters:
                image (int)(float): A 2d numpy array

        Returns:
                Plot an Image  
        &#39;&#39;&#39;        
        plt.imshow(image,&#39;gray&#39;)
        

    def display3D(self,volume):
        &#39;&#39;&#39;Returns the 3D plot given numpy array
        
        Parameters:
                image (int)(float): A 3d numpy array

        Returns:
                Plot 3d Image  
        &#39;&#39;&#39;

        p=volume.transpose(2,1,0)
        p = p[:,:,::-1]
        threshold=0.5
        alpha=0.5
        verts, faces, norm, val = measure.marching_cubes_lewiner(p, threshold)

        fig = plt.figure(figsize=(20, 20))
        ax = fig.add_subplot(111, projection=&#39;3d&#39;)

        # Fancy indexing: `verts[faces]` to generate a collection of triangles
        mesh = Poly3DCollection(verts[faces], alpha=alpha)
        face_color = [0.8, 0.2, 1]
        mesh.set_facecolor(face_color)
        ax.add_collection3d(mesh)

        ax.set_xlim(0, p.shape[0])
        ax.set_ylim(0, p.shape[1])
        ax.set_zlim(0, p.shape[2])

        plt.show()

    def intensityHist(self,array):
        
        &#39;&#39;&#39;
        it will plot intensity histogram of given array        
        Parameters:
                image (int)(float): A 2d or 3d numpy array

        Returns:
                Plots Image histogram  
        &#39;&#39;&#39;
        array = np.array(array)

        [counts,bins,bars]=plt.hist(array.flatten())     </code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="Healthhub.healthhub.display.display3D"><code class="name flex">
<span>def <span class="ident">display3D</span></span>(<span>self, volume)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the 3D plot given numpy array</p>
<h2 id="parameters">Parameters</h2>
<p>image (int)(float): A 3d numpy array</p>
<h2 id="returns">Returns</h2>
<p>Plot 3d Image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display3D(self,volume):
    &#39;&#39;&#39;Returns the 3D plot given numpy array
    
    Parameters:
            image (int)(float): A 3d numpy array

    Returns:
            Plot 3d Image  
    &#39;&#39;&#39;

    p=volume.transpose(2,1,0)
    p = p[:,:,::-1]
    threshold=0.5
    alpha=0.5
    verts, faces, norm, val = measure.marching_cubes_lewiner(p, threshold)

    fig = plt.figure(figsize=(20, 20))
    ax = fig.add_subplot(111, projection=&#39;3d&#39;)

    # Fancy indexing: `verts[faces]` to generate a collection of triangles
    mesh = Poly3DCollection(verts[faces], alpha=alpha)
    face_color = [0.8, 0.2, 1]
    mesh.set_facecolor(face_color)
    ax.add_collection3d(mesh)

    ax.set_xlim(0, p.shape[0])
    ax.set_ylim(0, p.shape[1])
    ax.set_zlim(0, p.shape[2])

    plt.show()</code></pre>
</details>
</dd>
<dt id="Healthhub.healthhub.display.intensityHist"><code class="name flex">
<span>def <span class="ident">intensityHist</span></span>(<span>self, array)</span>
</code></dt>
<dd>
<div class="desc"><p>it will plot intensity histogram of given array
</p>
<h2 id="parameters">Parameters</h2>
<p>image (int)(float): A 2d or 3d numpy array</p>
<h2 id="returns">Returns</h2>
<p>Plots Image histogram</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intensityHist(self,array):
    
    &#39;&#39;&#39;
    it will plot intensity histogram of given array        
    Parameters:
            image (int)(float): A 2d or 3d numpy array

    Returns:
            Plots Image histogram  
    &#39;&#39;&#39;
    array = np.array(array)

    [counts,bins,bars]=plt.hist(array.flatten())     </code></pre>
</details>
</dd>
<dt id="Healthhub.healthhub.display.multipleSlice"><code class="name flex">
<span>def <span class="ident">multipleSlice</span></span>(<span>self, volume)</span>
</code></dt>
<dd>
<div class="desc"><p>allows the user to navigate through different slices by using a slider widget</p>
<p>Parameters:
volume (int)(float): A 3d numpy array</p>
<h2 id="returns">Returns</h2>
<p>Mutiple slices (int)(float): axial , coronal and sagittal slices</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multipleSlice(self,volume):
    &#39;&#39;&#39;
    allows the user to navigate through different slices by using a slider widget
    
    Parameters:
    volume (int)(float): A 3d numpy array

    Returns:
            Mutiple slices (int)(float): axial , coronal and sagittal slices 
    &#39;&#39;&#39;

    figsize = (100,100)
    cmap = &#39;gray&#39;
    v = [np.min(volume), np.max(volume)] 

    def views():
        def plot_slice(z1, z2, z3):
            # Plot slice for the given plane and slice
            f,ax = plt.subplots(1,3, figsize=figsize)
            #print(self.figsize)
            #self.fig = plt.figure(figsize=self.figsize)
            #f(figsize = self.figsize)
            ax[0].imshow(vol1[:,:,z1], cmap=plt.get_cmap(cmap), 
                vmin=v[0], vmax=v[1])
            ax[1].imshow(vol2[:,:,z2], cmap=plt.get_cmap(cmap), 
                vmin=v[0], vmax=v[1])
            ax[2].imshow(vol3[:,:,z3], cmap=plt.get_cmap(cmap), 
                vmin=v[0], vmax=v[1])
            plt.show()

        vol1 = np.transpose(volume, [1,2,0])
        vol2 = np.rot90(np.transpose(volume, [2,0,1]), 3) #rotate 270 degrees
        vol3 = np.transpose(volume, [0,1,2])
        maxZ1 = vol1.shape[2] - 1
        maxZ2 = vol2.shape[2] - 1
        maxZ3 = vol3.shape[2] - 1
        ipyw.interact(plot_slice, 
            z1=ipyw.IntSlider(min=0, max=maxZ1, step=1, continuous_update=False, 
            description=&#39;Axial:&#39;), 
            z2=ipyw.IntSlider(min=0, max=maxZ2, step=1, continuous_update=False, 
            description=&#39;Coronal:&#39;),
            z3=ipyw.IntSlider(min=0, max=maxZ3, step=1, continuous_update=False, 
        description=&#39;Sagittal:&#39;))

    ipyw.interact(views)</code></pre>
</details>
</dd>
<dt id="Healthhub.healthhub.display.plotSlice"><code class="name flex">
<span>def <span class="ident">plotSlice</span></span>(<span>self, image)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the 2D plot of given slice image
</p>
<h2 id="parameters">Parameters</h2>
<p>image (int)(float): A 2d numpy array</p>
<h2 id="returns">Returns</h2>
<p>Plot an Image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plotSlice(self, image):
    &#39;&#39;&#39;
    Returns the 2D plot of given slice image        
    Parameters:
            image (int)(float): A 2d numpy array

    Returns:
            Plot an Image  
    &#39;&#39;&#39;        
    plt.imshow(image,&#39;gray&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Healthhub.healthhub.healthhub"><code class="flex name class">
<span>class <span class="ident">healthhub</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class healthhub:
    def __init__(self):
        self.dicom=dicom()
        self.image=Image_class()
        self.CV=CV()</code></pre>
</details>
</dd>
<dt id="Healthhub.healthhub.modify"><code class="flex name class">
<span>class <span class="ident">modify</span></span>
</code></dt>
<dd>
<div class="desc"><p>A class to represent modify.</p>
<p>&hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>tag(tags,ds,value):
it will
modify
tags
values in scan meta data</p>
<p>image(ds,image):
This function saves the provided image (rgb or gray scale) in the dataset</p>
<p>maxDiameter(full_mask,spacing):
This function finds the max diameter of 3D object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class modify:
    &#34;&#34;&#34;
    A class to represent modify.

    ...

    Attributes
    ----------
    name : None
    

    Methods
    -------
    
    tag(tags,ds,value):
        it will  modify   tags  values in scan meta data
         
    image(ds,image):
        This function saves the provided image (rgb or gray scale) in the dataset
       


    maxDiameter(full_mask,spacing):
        This function finds the max diameter of 3D object
         
    &#34;&#34;&#34;

    def __init__(self):
        
        pass
        &#34;&#34;&#34;
        Constructs all the necessary attributes for the diplay object.

        Parameters
        ----------
            name : None
            
        &#34;&#34;&#34;


    def tag(self,tags,ds,value):
        &#39;&#39;&#39;it will  modify   tags  values in scan meta data
         Parameters:
                ds  :  scan meta deta
                tags : tag number to modify
                value : new value for the tag

        Returns:
                ds : Meta data with new tag value 
                        
        &#39;&#39;&#39;        
        (x1,x2) = tags
        if (x1,x2) in ds:
            print(&#39;tag name: &#39;,ds[x1,x2].keyword)
            print(&#39;previous value: &#39;,ds[x1,x2].value)
            ds[x1,x2].value = value
            print(&#39;new value: &#39;,ds[x1,x2].value)
        else:
            print(&#39;Tag not found&#39;)
        return ds

    def image(self,image,output_path,dummy_dcm_path=&#39;&#39;):
        &#39;&#39;&#39;
        This function saves the provided image (rgb or gray scale) in the dataset
        Parameters:
                ds  :  scan meta deta
                image : numpy array
                

        Returns:
                ds : Meta data with image value 
                        
        &#39;&#39;&#39;
        if dummy_dcm_path==&#39;&#39;:
            dummy_dcm_path = &#39;dummy.dcm&#39;
        
        ds = pydicom.dcmread(dummy_dcm_path)
        
        ds.Rows = image.shape[0]
        ds.Columns = image.shape[1]

        if len(image.shape)&gt;2: ##rgb
            image = image.astype(np.uint8)
            ds.PhotometricInterpretation = &#39;RGB&#39;
            ds.PixelRepresentation = 0
            ds.WindowCenter = 127.5
            ds.WindowWidth = 255.0
            ds.SamplesPerPixel = 3
            ds.BitsAllocated = 8
            ds.BitsStored = 8
            ds.HighBit = 7
            if (0x0028, 0x0006) in ds:
                ds[0x0028, 0x0006].vaue = 0
            else:
                ds.add_new(0x00280006, &#39;US&#39;, 0)
        else:
            image = image.astype(np.int16)
        if (0x7fe0, 0x0010) in ds:
            ds.PixelData = image.tobytes()
        else:
            ds.add_new([0x7fe0, 0x0010], &#39;OB&#39;, image.tobytes())
        ds.save_as(output_path)



    def maxDiameter(full_mask,spacing):
        
        &#39;&#39;&#39;
        This function finds the max diameter of 3D object
         Parameters:
                full_mask  : it should contain all the slices of nodule
                spacing : pixel spacing
                

         Returns:
                ds : Meta data with image value 
                        
        &#39;&#39;&#39;
        # Ful mask means that it should contain all the slices of nodule, so shape can be like [6,45,45]
        # spacing is array contains spacing of x,y and z axis, shape should be like [0.7,1.5]

    #     full_mask = edge_mask(full_mask);    
        all_points = np.where(full_mask&gt;0)
        x_coor = all_points[1]
        y_coor = all_points[2]
        z_coor = all_points[0]

        pairs = []
        coordinates = []
    #     print(&#39;Number of points is {}&#39;.format(z_coor.min()))

        for i in range(z_coor.shape[0]):
            coor = [int(x_coor[i]),int(y_coor[i]),int(z_coor[i])]
            coordinates.append(coor)

        cpy = coordinates[:]

        for p in coordinates:
            cpy.remove(p)
            for points in cpy:
                pr = [p,points]
                pairs.append(pr)

        distances = np.zeros(len(pairs))
        i = 0
    #     print(&#39;Number of pairs is {}&#39;.format(len(pairs)))
        for pair in pairs:
            p_1 = pair[0]
            p_2 = pair[1]
            distances[i] = math.sqrt(((p_1[0] - p_2[0])*spacing[0])**2 + ((p_1[1] - p_2[1])*spacing[0])**2 + ((p_1[2] - p_2[2])*spacing[1])**2)
            i = i+1
        max_dis = float(distances.max())
        max_p = np.where(distances==distances.max())[0]
        max_pints = []
        for p in max_p:
            max_pints.append(pairs[p])
        return max_dis, max_pints</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="Healthhub.healthhub.modify.image"><code class="name flex">
<span>def <span class="ident">image</span></span>(<span>self, image, output_path, dummy_dcm_path='')</span>
</code></dt>
<dd>
<div class="desc"><p>This function saves the provided image (rgb or gray scale) in the dataset</p>
<h2 id="parameters">Parameters</h2>
<p>ds
:
scan meta deta
image : numpy array</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ds </code></dt>
<dd>Meta data with image value</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def image(self,image,output_path,dummy_dcm_path=&#39;&#39;):
    &#39;&#39;&#39;
    This function saves the provided image (rgb or gray scale) in the dataset
    Parameters:
            ds  :  scan meta deta
            image : numpy array
            

    Returns:
            ds : Meta data with image value 
                    
    &#39;&#39;&#39;
    if dummy_dcm_path==&#39;&#39;:
        dummy_dcm_path = &#39;dummy.dcm&#39;
    
    ds = pydicom.dcmread(dummy_dcm_path)
    
    ds.Rows = image.shape[0]
    ds.Columns = image.shape[1]

    if len(image.shape)&gt;2: ##rgb
        image = image.astype(np.uint8)
        ds.PhotometricInterpretation = &#39;RGB&#39;
        ds.PixelRepresentation = 0
        ds.WindowCenter = 127.5
        ds.WindowWidth = 255.0
        ds.SamplesPerPixel = 3
        ds.BitsAllocated = 8
        ds.BitsStored = 8
        ds.HighBit = 7
        if (0x0028, 0x0006) in ds:
            ds[0x0028, 0x0006].vaue = 0
        else:
            ds.add_new(0x00280006, &#39;US&#39;, 0)
    else:
        image = image.astype(np.int16)
    if (0x7fe0, 0x0010) in ds:
        ds.PixelData = image.tobytes()
    else:
        ds.add_new([0x7fe0, 0x0010], &#39;OB&#39;, image.tobytes())
    ds.save_as(output_path)</code></pre>
</details>
</dd>
<dt id="Healthhub.healthhub.modify.maxDiameter"><code class="name flex">
<span>def <span class="ident">maxDiameter</span></span>(<span>full_mask, spacing)</span>
</code></dt>
<dd>
<div class="desc"><p>This function finds the max diameter of 3D object
Parameters:
full_mask
: it should contain all the slices of nodule
spacing : pixel spacing</p>
<p>Returns:
ds : Meta data with image value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maxDiameter(full_mask,spacing):
    
    &#39;&#39;&#39;
    This function finds the max diameter of 3D object
     Parameters:
            full_mask  : it should contain all the slices of nodule
            spacing : pixel spacing
            

     Returns:
            ds : Meta data with image value 
                    
    &#39;&#39;&#39;
    # Ful mask means that it should contain all the slices of nodule, so shape can be like [6,45,45]
    # spacing is array contains spacing of x,y and z axis, shape should be like [0.7,1.5]

#     full_mask = edge_mask(full_mask);    
    all_points = np.where(full_mask&gt;0)
    x_coor = all_points[1]
    y_coor = all_points[2]
    z_coor = all_points[0]

    pairs = []
    coordinates = []
#     print(&#39;Number of points is {}&#39;.format(z_coor.min()))

    for i in range(z_coor.shape[0]):
        coor = [int(x_coor[i]),int(y_coor[i]),int(z_coor[i])]
        coordinates.append(coor)

    cpy = coordinates[:]

    for p in coordinates:
        cpy.remove(p)
        for points in cpy:
            pr = [p,points]
            pairs.append(pr)

    distances = np.zeros(len(pairs))
    i = 0
#     print(&#39;Number of pairs is {}&#39;.format(len(pairs)))
    for pair in pairs:
        p_1 = pair[0]
        p_2 = pair[1]
        distances[i] = math.sqrt(((p_1[0] - p_2[0])*spacing[0])**2 + ((p_1[1] - p_2[1])*spacing[0])**2 + ((p_1[2] - p_2[2])*spacing[1])**2)
        i = i+1
    max_dis = float(distances.max())
    max_p = np.where(distances==distances.max())[0]
    max_pints = []
    for p in max_p:
        max_pints.append(pairs[p])
    return max_dis, max_pints</code></pre>
</details>
</dd>
<dt id="Healthhub.healthhub.modify.tag"><code class="name flex">
<span>def <span class="ident">tag</span></span>(<span>self, tags, ds, value)</span>
</code></dt>
<dd>
<div class="desc"><p>it will
modify
tags
values in scan meta data
Parameters:
ds
:
scan meta deta
tags : tag number to modify
value : new value for the tag</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ds </code></dt>
<dd>Meta data with new tag value</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tag(self,tags,ds,value):
    &#39;&#39;&#39;it will  modify   tags  values in scan meta data
     Parameters:
            ds  :  scan meta deta
            tags : tag number to modify
            value : new value for the tag

    Returns:
            ds : Meta data with new tag value 
                    
    &#39;&#39;&#39;        
    (x1,x2) = tags
    if (x1,x2) in ds:
        print(&#39;tag name: &#39;,ds[x1,x2].keyword)
        print(&#39;previous value: &#39;,ds[x1,x2].value)
        ds[x1,x2].value = value
        print(&#39;new value: &#39;,ds[x1,x2].value)
    else:
        print(&#39;Tag not found&#39;)
    return ds</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Healthhub.healthhub.process"><code class="flex name class">
<span>class <span class="ident">process</span></span>
</code></dt>
<dd>
<div class="desc"><p>A class to represent process.</p>
<p>&hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>volumeCalculator(slices,spacing):
Returns the volume of an object in 3D binary mask in physical measurements.</p>
<p>getNormalized(scan,wc ,wl):
Returns the normalized volume.</p>
<p>windowing(self, scan,window_mode, window):
apply window function on the scan</p>
<p>Constructs all the necessary attributes for the diplay object.</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name : None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class process:
    &#34;&#34;&#34;
    A class to represent process.

    ...

    Attributes
    ----------
    name : None
    

    Methods
    -------
    
    volumeCalculator(slices,spacing):
        Returns the volume of an object in 3D binary mask in physical measurements.
    
    getNormalized(scan,wc ,wl):
        Returns the normalized volume.

    windowing(self, scan,window_mode, window):
        apply window function on the scan
    &#34;&#34;&#34;



    def __init__(self):
        &#34;&#34;&#34;
        Constructs all the necessary attributes for the diplay object.

        Parameters
        ----------
            name : None
            
        &#34;&#34;&#34;

        self.segmentation =segmentation()   
    
    def volumeCalculator(self,slices,spacing):
        &#34;&#34;&#34;
        Returns the volume of an object in 3D binary mask in physical measurements.

        This function takes 3D binary mask, of an object as an input along with pixel spacing and returns the physical volume as an output.     The unit of volume returned is same as the unit of pixel spacing (which is usually mm).

        :param slices: Slices containing binary mask, usually of tumor. 
        :type slices: int
        :param spacing: Takes in a list of pixel spacing as [px,py,pz] where px,py and pz are pixel spacings in x,y and z cordinates. 
        :type spacing: list

        :return: Returns the physical volume
        :rtype: float
        &#34;&#34;&#34;
        #def __init__(self, spacing=[None,None,None]):
        self.spacing[0]=spacing[0]
        self.spacing[1]=spacing[1]
        self.spacing[2]=spacing[2]


        v=0

        if len(slices.shape) == 2:
            assert len(self.spacing) != 2, &#34;Spacing should have two values, spacing should be a list of two numbers in case of 2D image&#34;

            assert self.spacing[0] != None, &#34;px cannot be None&#34;
            assert self.spacing[1] != None, &#34;py cannot be None&#34;

            v = np.sum(slices)*self.spacing[0]*self.spacing[1]
        else:
            assert len(self.spacing) == 3, &#34;pz should be defined&#34;

            assert self.spacing[0] != None, &#34;px cannot be None&#34;
            assert self.spacing[1] != None, &#34;py cannot be None&#34;
            assert self.spacing[2] != None, &#34;pz cannot be None&#34;
            for i in range(slices.shape[-1]):
                v=np.sum(slices)*self.spacing[2]*self.spacing[0]*self.spacing[1]

        return v
    
    def windowing(self, scan,window_mode, window):
        &#34;&#34;&#34;
        apply window function on the scan
        
        :param scan: input scan to be performed windowing on.
        :type number: pydicom.dataset.FileDataset
    
        :return: The result of windowing.
        :rtype: numpy.ndarray
        &#34;&#34;&#34;
        assert window_mode==&#39;min/max&#39; or window_mode==&#39;wl/ww&#39; or window_mode==&#39;scan_min/scan_max&#39;, &#34;window_mode should be defined!&#34;
        assert len(window)==2, &#34;Please define min/max or ww/wl values for windowing!&#34;
    
        import numpy as np
        if window_mode==&#39;wl/ww&#39;:
            assert window[0]!=None and self.window[1]!=None, &#34;WW/WL values cannot be None!&#34; 
            wl=self.window[0]
            ww=self.window[1]
            mn = wl - ww/2
            mx = wl + ww/2
        elif self.window_mode==&#39;min/max&#39;:
            assert self.window[0]!=None and self.window[1]!=None, &#34;Min/max values cannot be None!&#34;
            mn=self.window[0]
            mx=self.window[1]
        elif self.window_mode==&#39;scan_min/scan_max&#39;:
            mn = np.amin(scan)
            mx = np.amax(scan)
        
        d = mx - mn
        scan  = np.where(scan&lt;mn,mn, scan)
        scan  = np.where(scan&gt;mx,mx, scan)
        scan = (scan-mn)/d
        return scan
        


    def getNormalized(self,scan,wc ,wl):
        &#34;&#34;&#34;
        Returns the normalized volume.

        :param scan: 3D image to normalize. 
        :type nscan: int/float
        &#34;&#34;&#34;
        mn = wc - wl
        mx = wc+wl
        d = mx - mn
        scan  = np.where(scan&lt;mn,mn, scan)
        scan  = np.where(scan&gt;mx,mx, scan)
        scan = (scan-mn)/d
        return scan 

    def resize3D(self, nscan,shape):
        &#34;&#34;&#34;
        Returns the 3D volume after resizing it to the required shape.

        :param nscan: 3D image to resize. 
        :type nscan: int/float
        &#34;&#34;&#34;
        
        from scipy import ndimage
        assert len(shape)==3,&#34;The new shape should have 3 values&#34;
        assert len(shape)==3, &#34;Image should have 3 dimensions, given &#34;+str(len(nscan.shape))+ &#34; dimensions&#34;
        depth_factor=shape[0]/nscan.shape[0]
        width_factor=shape[2]/nscan.shape[2]
        height_factor=shape[1]/nscan.shape[1]

        if mask==False:
            nscan = ndimage.zoom(nscan, (depth_factor, height_factor, width_factor), order=1)
        elif is_mask==True:
            nscan = ndimage.zoom(nscan, (depth_factor, height_factor, width_factor), order=1, mode = &#39;nearest&#39; )
    
    
        return nscan</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="Healthhub.healthhub.process.getNormalized"><code class="name flex">
<span>def <span class="ident">getNormalized</span></span>(<span>self, scan, wc, wl)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the normalized volume.</p>
<p>:param scan: 3D image to normalize.
:type nscan: int/float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getNormalized(self,scan,wc ,wl):
    &#34;&#34;&#34;
    Returns the normalized volume.

    :param scan: 3D image to normalize. 
    :type nscan: int/float
    &#34;&#34;&#34;
    mn = wc - wl
    mx = wc+wl
    d = mx - mn
    scan  = np.where(scan&lt;mn,mn, scan)
    scan  = np.where(scan&gt;mx,mx, scan)
    scan = (scan-mn)/d
    return scan </code></pre>
</details>
</dd>
<dt id="Healthhub.healthhub.process.resize3D"><code class="name flex">
<span>def <span class="ident">resize3D</span></span>(<span>self, nscan, shape)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the 3D volume after resizing it to the required shape.</p>
<p>:param nscan: 3D image to resize.
:type nscan: int/float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resize3D(self, nscan,shape):
    &#34;&#34;&#34;
    Returns the 3D volume after resizing it to the required shape.

    :param nscan: 3D image to resize. 
    :type nscan: int/float
    &#34;&#34;&#34;
    
    from scipy import ndimage
    assert len(shape)==3,&#34;The new shape should have 3 values&#34;
    assert len(shape)==3, &#34;Image should have 3 dimensions, given &#34;+str(len(nscan.shape))+ &#34; dimensions&#34;
    depth_factor=shape[0]/nscan.shape[0]
    width_factor=shape[2]/nscan.shape[2]
    height_factor=shape[1]/nscan.shape[1]

    if mask==False:
        nscan = ndimage.zoom(nscan, (depth_factor, height_factor, width_factor), order=1)
    elif is_mask==True:
        nscan = ndimage.zoom(nscan, (depth_factor, height_factor, width_factor), order=1, mode = &#39;nearest&#39; )


    return nscan</code></pre>
</details>
</dd>
<dt id="Healthhub.healthhub.process.volumeCalculator"><code class="name flex">
<span>def <span class="ident">volumeCalculator</span></span>(<span>self, slices, spacing)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the volume of an object in 3D binary mask in physical measurements.</p>
<p>This function takes 3D binary mask, of an object as an input along with pixel spacing and returns the physical volume as an output.
The unit of volume returned is same as the unit of pixel spacing (which is usually mm).</p>
<p>:param slices: Slices containing binary mask, usually of tumor.
:type slices: int
:param spacing: Takes in a list of pixel spacing as [px,py,pz] where px,py and pz are pixel spacings in x,y and z cordinates.
:type spacing: list</p>
<p>:return: Returns the physical volume
:rtype: float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def volumeCalculator(self,slices,spacing):
    &#34;&#34;&#34;
    Returns the volume of an object in 3D binary mask in physical measurements.

    This function takes 3D binary mask, of an object as an input along with pixel spacing and returns the physical volume as an output.     The unit of volume returned is same as the unit of pixel spacing (which is usually mm).

    :param slices: Slices containing binary mask, usually of tumor. 
    :type slices: int
    :param spacing: Takes in a list of pixel spacing as [px,py,pz] where px,py and pz are pixel spacings in x,y and z cordinates. 
    :type spacing: list

    :return: Returns the physical volume
    :rtype: float
    &#34;&#34;&#34;
    #def __init__(self, spacing=[None,None,None]):
    self.spacing[0]=spacing[0]
    self.spacing[1]=spacing[1]
    self.spacing[2]=spacing[2]


    v=0

    if len(slices.shape) == 2:
        assert len(self.spacing) != 2, &#34;Spacing should have two values, spacing should be a list of two numbers in case of 2D image&#34;

        assert self.spacing[0] != None, &#34;px cannot be None&#34;
        assert self.spacing[1] != None, &#34;py cannot be None&#34;

        v = np.sum(slices)*self.spacing[0]*self.spacing[1]
    else:
        assert len(self.spacing) == 3, &#34;pz should be defined&#34;

        assert self.spacing[0] != None, &#34;px cannot be None&#34;
        assert self.spacing[1] != None, &#34;py cannot be None&#34;
        assert self.spacing[2] != None, &#34;pz cannot be None&#34;
        for i in range(slices.shape[-1]):
            v=np.sum(slices)*self.spacing[2]*self.spacing[0]*self.spacing[1]

    return v</code></pre>
</details>
</dd>
<dt id="Healthhub.healthhub.process.windowing"><code class="name flex">
<span>def <span class="ident">windowing</span></span>(<span>self, scan, window_mode, window)</span>
</code></dt>
<dd>
<div class="desc"><p>apply window function on the scan</p>
<p>:param scan: input scan to be performed windowing on.
:type number: pydicom.dataset.FileDataset</p>
<p>:return: The result of windowing.
:rtype: numpy.ndarray</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def windowing(self, scan,window_mode, window):
    &#34;&#34;&#34;
    apply window function on the scan
    
    :param scan: input scan to be performed windowing on.
    :type number: pydicom.dataset.FileDataset

    :return: The result of windowing.
    :rtype: numpy.ndarray
    &#34;&#34;&#34;
    assert window_mode==&#39;min/max&#39; or window_mode==&#39;wl/ww&#39; or window_mode==&#39;scan_min/scan_max&#39;, &#34;window_mode should be defined!&#34;
    assert len(window)==2, &#34;Please define min/max or ww/wl values for windowing!&#34;

    import numpy as np
    if window_mode==&#39;wl/ww&#39;:
        assert window[0]!=None and self.window[1]!=None, &#34;WW/WL values cannot be None!&#34; 
        wl=self.window[0]
        ww=self.window[1]
        mn = wl - ww/2
        mx = wl + ww/2
    elif self.window_mode==&#39;min/max&#39;:
        assert self.window[0]!=None and self.window[1]!=None, &#34;Min/max values cannot be None!&#34;
        mn=self.window[0]
        mx=self.window[1]
    elif self.window_mode==&#39;scan_min/scan_max&#39;:
        mn = np.amin(scan)
        mx = np.amax(scan)
    
    d = mx - mn
    scan  = np.where(scan&lt;mn,mn, scan)
    scan  = np.where(scan&gt;mx,mx, scan)
    scan = (scan-mn)/d
    return scan</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Healthhub.healthhub.read"><code class="flex name class">
<span>class <span class="ident">read</span></span>
</code></dt>
<dd>
<div class="desc"><p>A class to represent read.</p>
<p>&hellip;</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>scan(folder_path):
it will
take path of scan as input and return scan array in 4d and its metadeta</p>
<p>Slice(slice_path):
it will
take path of slice as input and return slice array
and its metadeta</p>
<p>tag(tags,ds):
it will
return the given tags values </p>
<p>getSeriesPlane(ds):
it will
return the
tags with in getSeriesPlane </p>
<p>orientation(self,orientation_tag_value):
it will
return orientation tag value as a type string</p>
<p>seriesData(ds): <br>
it will
returns a list of sopseriesUID, series_number, view corresponding to each series</p>
<p>getImagePlane(self,meta_data):<br>
it will
returns
all the tags within ImagePlane
module</p>
<p>getFrameOfReference(self,meta_data): ##Public func
it will
returns
all the tags within FrameOfReference
module</p>
<p>getPatientStudy(self,meta_data):
it will
returns
all the tags within getPatientStudy
module</p>
<p>getGeneralStudy(self,meta_data):
it will
returns
all the tags within getGeneralStudy
module</p>
<p>getImagePixel(meta_data):
<br>
it will
returns
all the tags within getImagePixel
module</p>
<p>Constructs all the necessary attributes for the diplay object.</p>
<h2 id="parameters">Parameters</h2>
<pre><code>name : None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class read:
    &#34;&#34;&#34;
    A class to represent read.

    ...

    Attributes
    ----------
    name : None
    

    Methods
    -------
     
    scan(folder_path): 
        it will  take path of scan as input and return scan array in 4d and its metadeta
        
    Slice(slice_path):
        it will  take path of slice as input and return slice array  and its metadeta
        
    tag(tags,ds):
         it will  return the given tags values 
        
    getSeriesPlane(ds):
         it will  return the  tags with in getSeriesPlane 
    
    orientation(self,orientation_tag_value): 
         it will  return orientation tag value as a type string
         
    seriesData(ds):   
         it will  returns a list of sopseriesUID, series_number, view corresponding to each series

    
    getImagePlane(self,meta_data):  
         it will  returns  all the tags within ImagePlane  module
         
    getFrameOfReference(self,meta_data): ##Public func
         it will  returns  all the tags within FrameOfReference  module
         
    getPatientStudy(self,meta_data):
         it will  returns  all the tags within getPatientStudy  module
         
    getGeneralStudy(self,meta_data): 
         it will  returns  all the tags within getGeneralStudy  module
        
    getImagePixel(meta_data):    
          it will  returns  all the tags within getImagePixel  module
        
        
    &#34;&#34;&#34;

    def __init__(self):#, folder_path):
        &#34;&#34;&#34;
        Constructs all the necessary attributes for the diplay object.

        Parameters
        ----------
            name : None
            
        &#34;&#34;&#34;

        pass
        #super().__init__()

    def scan(self,folder_path): ##Public func
        &#39;&#39;&#39;
        it will  take path of scan as input and return scan array in 4d and its metadeta
        
        Parameters:
                folder_path : path of given dicom scan

        Returns:
                (int)(float): Scan 
                            : Meta Data
        &#39;&#39;&#39;        
       
        
        files = self.sorted_files(folder_path)
        f, myscan, mytags = self.read_scan(folder_path,files)
        return myscan, mytags

    def sorted_files(self,folder): ##Private function
        ins=[]
        ori = []
        ser=[]
        f= os.listdir(folder)
        for name in tqdm(f):
            itkimage = sitk.ReadImage(os.path.join(folder,name))
            temp= float(itkimage.GetMetaData(&#39;0020|0013&#39;)) # instance number 
            temp1= itkimage.GetMetaData(&#39;0020|000e&#39;) #series instance UID 
            ins.append(int(temp))
            ser.append(temp1)
        series=np.unique(ser)

        files=[[x for sr,_,x in sorted(zip(ser,ins,f)) if sr==s] for s in series]
        return files


    def read_scan(self,folder_path,files): ##Private func
        axial  =  np.array([1., 0., 0., 0., 1., 0.])
        coronal = np.array([1., 0., 0., 0., 0., -1.])
        sagittal= np.array([0., 1., 0., 0., 0., -1.])
        myscan = []
        mytags = []
        f=[]
        for i in tqdm (range (len(files))):
            img=[]
            file=[]
            tags = []
            for filename in files[i]:
                ds = pydicom.dcmread(os.path.join(folder_path,filename))
                numpyImage = ds.pixel_array
                del ds[0x7fe0, 0x0010]
                img.append(numpyImage)
                file.append(filename)
                tags.append(ds)
            mytags.append(tags)
            myscan.append(img)
            f.append(file)
        return f, myscan, mytags

    def Slice(self, slice_path): ##Public
        &#39;&#39;&#39;
        it will  take path of slice as input and return slice array  and its metadeta
        
        Parameters:
                folder_path : path of given dicom scan

        Returns:
                (int)(float): Slice 
                            : Meta Data
        &#39;&#39;&#39;        
        ds = pydicom.dcmread(slice_path)
        numpyImage = ds.pixel_array
        return numpyImage, ds

    #def seriesPlaneData(self): ##public
    #    &#39;&#39;&#39;it will  display module series plane data&#39;&#39;&#39;
    #    print(&#39;Series Orientation: &#39;,self.orient)
    #    print(&#39;Series Instance UID: &#39;,self.series_ins_uid)
    #    return self.orient,self.series_ins_uid

    def tag(self,tags,ds): ##Public
        &#39;&#39;&#39;it will  return the given tags values 
        
        Parameters:
                tags : any tags of given dicom scan
                ds : meta deta of dicom scan

        Returns:
                (int)(float)(String): Tag Value 
                            
        &#39;&#39;&#39;
        (x1,x2) = tags
        if (x1,x2) in ds:
            print(ds[x1,x2])
            return ds[x1,x2].value
        else:
            print(&#39;Tag not found&#39;)
    
    ###
    def getSeriesPlane(self,ds): ##public
        &#39;&#39;&#39;it will  return the  tags with in getSeriesPlane 
        
        Parameters:
                ds= meta deta
                
        Returns:
                Series Orientation, Series Instance UID                            
        &#39;&#39;&#39;
        l=[]
        if ((0x0020,0x0037) in ds):
            o=ds[0x0020,0x0037].value
            
        else:
            o=&#39;&#39;
        if ((0x0020,0x000e) in ds):
            s=ds[0x0020,0x000e].value
            #print(&#34;hi&#34;)
        else:
            s=&#39;&#39;
        l.append([o,s])

        return l

    

    def orientation(self,orientation_tag_value): ##Public func
        &#39;&#39;&#39;
        it will  return orientation tag value as a type string
        
        Parameters:
                orientation_tag_value : orientation tag

        Returns:
                (string): Orientation of tag [axial, sagittal or coronal] 
                        
        &#39;&#39;&#39;
        axial  =  np.array([1., 0., 0., 0., 1., 0.])
        coronal = np.array([1., 0., 0., 0., 0., -1.])
        sagittal= np.array([0., 1., 0., 0., 0., -1.])

        a = np.around(orientation_tag_value)

        if (a==coronal).all():
            return &#39;coronal&#39;
        elif (a==axial).all():
            return &#39;axial&#39;
        elif (a==sagittal).all():
            return &#39;sagittal&#39;
        else:
            print(&#39;orientation not found&#39;)
            return &#39;&#39;

    def seriesData(self,ds):   ##Public func
        &#39;&#39;&#39;it will  returns a list of sopseriesUID, series_number, view corresponding to each series
         Parameters:
                ds  :  scan meta deta

        Returns:
                (list):  [sopseriesUID, series_number, view corresponding to each series] 
                        
        &#39;&#39;&#39;

        n=len(ds)
        l=[]
        for i in range(n):
            a = ds[i][0][0x0020,0x000e].value if ((0x0020,0x000e) in ds[i][0]) else &#39;&#39;
            if ((0x0020,0x0037) in ds[i][0]):
                b = self.orientation(ds[i][0][0x0020,0x0037].value)
            else:
                b = &#39;no orientation tag&#39;
            #b = ds[i][0][0x0020,0x0037].value if ((0x0020,0x0037) in ds[i][0]) else &#39;&#39;
            c = ds[i][0][0x0020,0x0011].value if ((0x0020,0x0011) in ds[i][0]) else &#39;&#39;
            l.append([a,b,c])

        return l




    def getImagePlane(self,meta_data):  ##Public func
        #Pixel Spacing
        &#39;&#39;&#39;it will  returns  all the tags within ImagePlane  module
         Parameters:
                ds  :  scan meta deta

        Returns:
                table : Tag Name, Tag Code and Tag Values with in imagePlane Module 
                        
        &#39;&#39;&#39;
        data =meta_data.group_dataset(0x0020)


        #col_names = [&#34;Tag Name&#34;, &#34;Tag Code&#34;,&#34;Tag Value&#34;]
        #print(tabulate(data, headers=col_names))
        return data



    def getFrameOfReference(self,meta_data): ##Public func
        &#39;&#39;&#39;it will  returns  all the tags within FrameOfReference  module
         Parameters:
                ds  :  scan meta deta

         Returns:
                table : Tag Name, Tag Code and Tag Values with in FrameOfReference Module 
                        
         &#39;&#39;&#39;
        data = meta_data.group_dataset(0x0020)

       # print(data)
        return data

    def getPatientStudy(self,meta_data):
        &#39;&#39;&#39;it will  returns  all the tags within getPatientStudy  module
         Parameters:
                ds  :  scan meta deta

         Returns:
                table : Tag Name, Tag Code and Tag Values with in getPatientStudy Module 
                        
         &#39;&#39;&#39;   
        data=meta_data.group_dataset(0x0010)

        #col_names = [&#34;Tag Name&#34;, &#34;Tag Code&#34;,&#34;Tag Value&#34;]

        #print(data)
        return data


    def getGeneralStudy(self,meta_data): ##Public func
        &#39;&#39;&#39;it will  returns  all the tags within getGeneralStudy  module
         Parameters:
                ds  :  scan meta deta

         Returns:
                table : Tag Name, Tag Code and Tag Values with in getGeneralStudy Module 
                        
        &#39;&#39;&#39;   
       

        data =meta_data.group_dataset(0x0008) 

        #print(data)
        return data

    def getImagePixel(self,meta_data):    ##Public func
        &#39;&#39;&#39;it will  returns  all the tags within getImagePixel  module
         Parameters:
                ds  :  scan meta deta

         Returns:
                table : Tag Name, Tag Code and Tag Values with in getImagePixel Module 
                        
        &#39;&#39;&#39;
        data = meta_data.group_dataset(0x0028) 

            #    [&#34;Bits Stored &#34;, &#34;(0008,0101)&#34;,meta_data[0x0028,0x0101].value],
             #   [&#34;High Bit &#34;, &#34;(0008,0102)&#34;,meta_data[0x0028,0x0102].value],
             #   [&#34;Pixel Representation &#34;, &#34;(0008,0103)&#34;,meta_data[0x0028,0x0103].value]]
        #col_names = [&#34;Tag Name&#34;, &#34;Tag Code&#34;,&#34;Tag Value&#34;]

        #print(data)
        return data</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="Healthhub.healthhub.read.Slice"><code class="name flex">
<span>def <span class="ident">Slice</span></span>(<span>self, slice_path)</span>
</code></dt>
<dd>
<div class="desc"><p>it will
take path of slice as input and return slice array
and its metadeta</p>
<h2 id="parameters">Parameters</h2>
<p>folder_path : path of given dicom scan</p>
<h2 id="returns">Returns</h2>
<dl>
<dt>(int)(float): Slice</dt>
<dt><code>
</code></dt>
<dd>Meta Data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Slice(self, slice_path): ##Public
    &#39;&#39;&#39;
    it will  take path of slice as input and return slice array  and its metadeta
    
    Parameters:
            folder_path : path of given dicom scan

    Returns:
            (int)(float): Slice 
                        : Meta Data
    &#39;&#39;&#39;        
    ds = pydicom.dcmread(slice_path)
    numpyImage = ds.pixel_array
    return numpyImage, ds</code></pre>
</details>
</dd>
<dt id="Healthhub.healthhub.read.getFrameOfReference"><code class="name flex">
<span>def <span class="ident">getFrameOfReference</span></span>(<span>self, meta_data)</span>
</code></dt>
<dd>
<div class="desc"><p>it will
returns
all the tags within FrameOfReference
module</p>
<h2 id="parameters">Parameters</h2>
<p>ds
:
scan meta deta</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>table </code></dt>
<dd>Tag Name, Tag Code and Tag Values with in FrameOfReference Module</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getFrameOfReference(self,meta_data): ##Public func
    &#39;&#39;&#39;it will  returns  all the tags within FrameOfReference  module
     Parameters:
            ds  :  scan meta deta

     Returns:
            table : Tag Name, Tag Code and Tag Values with in FrameOfReference Module 
                    
     &#39;&#39;&#39;
    data = meta_data.group_dataset(0x0020)

   # print(data)
    return data</code></pre>
</details>
</dd>
<dt id="Healthhub.healthhub.read.getGeneralStudy"><code class="name flex">
<span>def <span class="ident">getGeneralStudy</span></span>(<span>self, meta_data)</span>
</code></dt>
<dd>
<div class="desc"><p>it will
returns
all the tags within getGeneralStudy
module</p>
<h2 id="parameters">Parameters</h2>
<p>ds
:
scan meta deta</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>table </code></dt>
<dd>Tag Name, Tag Code and Tag Values with in getGeneralStudy Module</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getGeneralStudy(self,meta_data): ##Public func
    &#39;&#39;&#39;it will  returns  all the tags within getGeneralStudy  module
     Parameters:
            ds  :  scan meta deta

     Returns:
            table : Tag Name, Tag Code and Tag Values with in getGeneralStudy Module 
                    
    &#39;&#39;&#39;   
   

    data =meta_data.group_dataset(0x0008) 

    #print(data)
    return data</code></pre>
</details>
</dd>
<dt id="Healthhub.healthhub.read.getImagePixel"><code class="name flex">
<span>def <span class="ident">getImagePixel</span></span>(<span>self, meta_data)</span>
</code></dt>
<dd>
<div class="desc"><p>it will
returns
all the tags within getImagePixel
module</p>
<h2 id="parameters">Parameters</h2>
<p>ds
:
scan meta deta</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>table </code></dt>
<dd>Tag Name, Tag Code and Tag Values with in getImagePixel Module</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getImagePixel(self,meta_data):    ##Public func
    &#39;&#39;&#39;it will  returns  all the tags within getImagePixel  module
     Parameters:
            ds  :  scan meta deta

     Returns:
            table : Tag Name, Tag Code and Tag Values with in getImagePixel Module 
                    
    &#39;&#39;&#39;
    data = meta_data.group_dataset(0x0028) 

        #    [&#34;Bits Stored &#34;, &#34;(0008,0101)&#34;,meta_data[0x0028,0x0101].value],
         #   [&#34;High Bit &#34;, &#34;(0008,0102)&#34;,meta_data[0x0028,0x0102].value],
         #   [&#34;Pixel Representation &#34;, &#34;(0008,0103)&#34;,meta_data[0x0028,0x0103].value]]
    #col_names = [&#34;Tag Name&#34;, &#34;Tag Code&#34;,&#34;Tag Value&#34;]

    #print(data)
    return data</code></pre>
</details>
</dd>
<dt id="Healthhub.healthhub.read.getImagePlane"><code class="name flex">
<span>def <span class="ident">getImagePlane</span></span>(<span>self, meta_data)</span>
</code></dt>
<dd>
<div class="desc"><p>it will
returns
all the tags within ImagePlane
module
Parameters:
ds
:
scan meta deta</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>table </code></dt>
<dd>Tag Name, Tag Code and Tag Values with in imagePlane Module</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getImagePlane(self,meta_data):  ##Public func
    #Pixel Spacing
    &#39;&#39;&#39;it will  returns  all the tags within ImagePlane  module
     Parameters:
            ds  :  scan meta deta

    Returns:
            table : Tag Name, Tag Code and Tag Values with in imagePlane Module 
                    
    &#39;&#39;&#39;
    data =meta_data.group_dataset(0x0020)


    #col_names = [&#34;Tag Name&#34;, &#34;Tag Code&#34;,&#34;Tag Value&#34;]
    #print(tabulate(data, headers=col_names))
    return data</code></pre>
</details>
</dd>
<dt id="Healthhub.healthhub.read.getPatientStudy"><code class="name flex">
<span>def <span class="ident">getPatientStudy</span></span>(<span>self, meta_data)</span>
</code></dt>
<dd>
<div class="desc"><p>it will
returns
all the tags within getPatientStudy
module</p>
<h2 id="parameters">Parameters</h2>
<p>ds
:
scan meta deta</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>table </code></dt>
<dd>Tag Name, Tag Code and Tag Values with in getPatientStudy Module</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getPatientStudy(self,meta_data):
    &#39;&#39;&#39;it will  returns  all the tags within getPatientStudy  module
     Parameters:
            ds  :  scan meta deta

     Returns:
            table : Tag Name, Tag Code and Tag Values with in getPatientStudy Module 
                    
     &#39;&#39;&#39;   
    data=meta_data.group_dataset(0x0010)

    #col_names = [&#34;Tag Name&#34;, &#34;Tag Code&#34;,&#34;Tag Value&#34;]

    #print(data)
    return data</code></pre>
</details>
</dd>
<dt id="Healthhub.healthhub.read.getSeriesPlane"><code class="name flex">
<span>def <span class="ident">getSeriesPlane</span></span>(<span>self, ds)</span>
</code></dt>
<dd>
<div class="desc"><p>it will
return the
tags with in getSeriesPlane </p>
<h2 id="parameters">Parameters</h2>
<p>ds= meta deta</p>
<h2 id="returns">Returns</h2>
<p>Series Orientation, Series Instance UID</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSeriesPlane(self,ds): ##public
    &#39;&#39;&#39;it will  return the  tags with in getSeriesPlane 
    
    Parameters:
            ds= meta deta
            
    Returns:
            Series Orientation, Series Instance UID                            
    &#39;&#39;&#39;
    l=[]
    if ((0x0020,0x0037) in ds):
        o=ds[0x0020,0x0037].value
        
    else:
        o=&#39;&#39;
    if ((0x0020,0x000e) in ds):
        s=ds[0x0020,0x000e].value
        #print(&#34;hi&#34;)
    else:
        s=&#39;&#39;
    l.append([o,s])

    return l</code></pre>
</details>
</dd>
<dt id="Healthhub.healthhub.read.orientation"><code class="name flex">
<span>def <span class="ident">orientation</span></span>(<span>self, orientation_tag_value)</span>
</code></dt>
<dd>
<div class="desc"><p>it will
return orientation tag value as a type string</p>
<h2 id="parameters">Parameters</h2>
<p>orientation_tag_value : orientation tag</p>
<h2 id="returns">Returns</h2>
<p>(string): Orientation of tag [axial, sagittal or coronal]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def orientation(self,orientation_tag_value): ##Public func
    &#39;&#39;&#39;
    it will  return orientation tag value as a type string
    
    Parameters:
            orientation_tag_value : orientation tag

    Returns:
            (string): Orientation of tag [axial, sagittal or coronal] 
                    
    &#39;&#39;&#39;
    axial  =  np.array([1., 0., 0., 0., 1., 0.])
    coronal = np.array([1., 0., 0., 0., 0., -1.])
    sagittal= np.array([0., 1., 0., 0., 0., -1.])

    a = np.around(orientation_tag_value)

    if (a==coronal).all():
        return &#39;coronal&#39;
    elif (a==axial).all():
        return &#39;axial&#39;
    elif (a==sagittal).all():
        return &#39;sagittal&#39;
    else:
        print(&#39;orientation not found&#39;)
        return &#39;&#39;</code></pre>
</details>
</dd>
<dt id="Healthhub.healthhub.read.read_scan"><code class="name flex">
<span>def <span class="ident">read_scan</span></span>(<span>self, folder_path, files)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_scan(self,folder_path,files): ##Private func
    axial  =  np.array([1., 0., 0., 0., 1., 0.])
    coronal = np.array([1., 0., 0., 0., 0., -1.])
    sagittal= np.array([0., 1., 0., 0., 0., -1.])
    myscan = []
    mytags = []
    f=[]
    for i in tqdm (range (len(files))):
        img=[]
        file=[]
        tags = []
        for filename in files[i]:
            ds = pydicom.dcmread(os.path.join(folder_path,filename))
            numpyImage = ds.pixel_array
            del ds[0x7fe0, 0x0010]
            img.append(numpyImage)
            file.append(filename)
            tags.append(ds)
        mytags.append(tags)
        myscan.append(img)
        f.append(file)
    return f, myscan, mytags</code></pre>
</details>
</dd>
<dt id="Healthhub.healthhub.read.scan"><code class="name flex">
<span>def <span class="ident">scan</span></span>(<span>self, folder_path)</span>
</code></dt>
<dd>
<div class="desc"><p>it will
take path of scan as input and return scan array in 4d and its metadeta</p>
<h2 id="parameters">Parameters</h2>
<p>folder_path : path of given dicom scan</p>
<h2 id="returns">Returns</h2>
<dl>
<dt>(int)(float): Scan</dt>
<dt><code>
</code></dt>
<dd>Meta Data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scan(self,folder_path): ##Public func
    &#39;&#39;&#39;
    it will  take path of scan as input and return scan array in 4d and its metadeta
    
    Parameters:
            folder_path : path of given dicom scan

    Returns:
            (int)(float): Scan 
                        : Meta Data
    &#39;&#39;&#39;        
   
    
    files = self.sorted_files(folder_path)
    f, myscan, mytags = self.read_scan(folder_path,files)
    return myscan, mytags</code></pre>
</details>
</dd>
<dt id="Healthhub.healthhub.read.seriesData"><code class="name flex">
<span>def <span class="ident">seriesData</span></span>(<span>self, ds)</span>
</code></dt>
<dd>
<div class="desc"><p>it will
returns a list of sopseriesUID, series_number, view corresponding to each series
Parameters:
ds
:
scan meta deta</p>
<h2 id="returns">Returns</h2>
<p>(list):
[sopseriesUID, series_number, view corresponding to each series]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def seriesData(self,ds):   ##Public func
    &#39;&#39;&#39;it will  returns a list of sopseriesUID, series_number, view corresponding to each series
     Parameters:
            ds  :  scan meta deta

    Returns:
            (list):  [sopseriesUID, series_number, view corresponding to each series] 
                    
    &#39;&#39;&#39;

    n=len(ds)
    l=[]
    for i in range(n):
        a = ds[i][0][0x0020,0x000e].value if ((0x0020,0x000e) in ds[i][0]) else &#39;&#39;
        if ((0x0020,0x0037) in ds[i][0]):
            b = self.orientation(ds[i][0][0x0020,0x0037].value)
        else:
            b = &#39;no orientation tag&#39;
        #b = ds[i][0][0x0020,0x0037].value if ((0x0020,0x0037) in ds[i][0]) else &#39;&#39;
        c = ds[i][0][0x0020,0x0011].value if ((0x0020,0x0011) in ds[i][0]) else &#39;&#39;
        l.append([a,b,c])

    return l</code></pre>
</details>
</dd>
<dt id="Healthhub.healthhub.read.sorted_files"><code class="name flex">
<span>def <span class="ident">sorted_files</span></span>(<span>self, folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sorted_files(self,folder): ##Private function
    ins=[]
    ori = []
    ser=[]
    f= os.listdir(folder)
    for name in tqdm(f):
        itkimage = sitk.ReadImage(os.path.join(folder,name))
        temp= float(itkimage.GetMetaData(&#39;0020|0013&#39;)) # instance number 
        temp1= itkimage.GetMetaData(&#39;0020|000e&#39;) #series instance UID 
        ins.append(int(temp))
        ser.append(temp1)
    series=np.unique(ser)

    files=[[x for sr,_,x in sorted(zip(ser,ins,f)) if sr==s] for s in series]
    return files</code></pre>
</details>
</dd>
<dt id="Healthhub.healthhub.read.tag"><code class="name flex">
<span>def <span class="ident">tag</span></span>(<span>self, tags, ds)</span>
</code></dt>
<dd>
<div class="desc"><p>it will
return the given tags values </p>
<h2 id="parameters">Parameters</h2>
<p>tags : any tags of given dicom scan
ds : meta deta of dicom scan</p>
<h2 id="returns">Returns</h2>
<p>(int)(float)(String): Tag Value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tag(self,tags,ds): ##Public
    &#39;&#39;&#39;it will  return the given tags values 
    
    Parameters:
            tags : any tags of given dicom scan
            ds : meta deta of dicom scan

    Returns:
            (int)(float)(String): Tag Value 
                        
    &#39;&#39;&#39;
    (x1,x2) = tags
    if (x1,x2) in ds:
        print(ds[x1,x2])
        return ds[x1,x2].value
    else:
        print(&#39;Tag not found&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Healthhub.healthhub.segmentation"><code class="flex name class">
<span>class <span class="ident">segmentation</span></span>
<span>(</span><span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>"</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>generic_window(ds):</p>
<p>boneSeg(scan,wc ,wl):</p>
<p>seg():</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class segmentation:
    &#34;&#34;&#34;&#34;

    Attributes
    ----------
    name : None
    

    Methods
    -------
    
    generic_window(ds):
        
    boneSeg(scan,wc ,wl):
      
    seg():
        &#34;&#34;&#34;
   
    
    def __init__(self, path):
        self.path=path
        
    def genericWindow(self,ds):
        
        def get_normalized(scan,wc ,wl):
            mn = wc - wl
            mx = wc+wl
            d = mx - mn
            scan  = np.where(scan&lt;mn,mn, scan)
            scan  = np.where(scan&gt;mx,mx, scan)
            scan = (scan-mn)/d
            return scan  
        
        wc= ds[0x28,0x1050].value  #window center
        w=(ds[0x28,0x1051].value) #window width
        ww=int(w/2)
       
        new_wc=wc+(0.3*wc)
        new_ww=(0.8*ww)   
        
        img=ds.pixel_array
        result=get_normalized(img,wc+(0.3*wc),(0.8*ww) )
     
        return result
    
    def boneSeg(self,ds):
    
        def normal(un):
            mn = np.amin(un)
            mx = np.amax(un)
            d = mx - mn
            normalized = (un-mn)/d
            return normalized
        
        def get_normalized(scan):
            wc= (300-(-1000))/(1000-(-1000)) #normalizing WC
            w= (1000-(-1000))/(1000-(-1000))  #normalizing WW
            wl=w/2
            mn = wc - wl
            mx = wc+wl
            d = mx - mn
            scan  = np.where(scan&lt;mn,mn, scan)
            scan  = np.where(scan&gt;mx,mx, scan)
            scan = (scan-mn)/d
            return scan        

        img=ds.pixel_array
        normal_img=normal(img)
        final_image=get_normalized(normal_img)

        return final_image     
    
    def seg(self):
        
        import pydicom
        ds=pydicom.dcmread(self.path)
        #img=ds.pixel_array
        try: 
            wc= ds[0x28,0x1050].value  #window center
            w=ds[0x28,0x1051].value #window width
            res = self.generic_window(ds)
        except:
            res = self.bone_seg(ds)
        
        return res</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="Healthhub.healthhub.segmentation.boneSeg"><code class="name flex">
<span>def <span class="ident">boneSeg</span></span>(<span>self, ds)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def boneSeg(self,ds):

    def normal(un):
        mn = np.amin(un)
        mx = np.amax(un)
        d = mx - mn
        normalized = (un-mn)/d
        return normalized
    
    def get_normalized(scan):
        wc= (300-(-1000))/(1000-(-1000)) #normalizing WC
        w= (1000-(-1000))/(1000-(-1000))  #normalizing WW
        wl=w/2
        mn = wc - wl
        mx = wc+wl
        d = mx - mn
        scan  = np.where(scan&lt;mn,mn, scan)
        scan  = np.where(scan&gt;mx,mx, scan)
        scan = (scan-mn)/d
        return scan        

    img=ds.pixel_array
    normal_img=normal(img)
    final_image=get_normalized(normal_img)

    return final_image     </code></pre>
</details>
</dd>
<dt id="Healthhub.healthhub.segmentation.genericWindow"><code class="name flex">
<span>def <span class="ident">genericWindow</span></span>(<span>self, ds)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def genericWindow(self,ds):
    
    def get_normalized(scan,wc ,wl):
        mn = wc - wl
        mx = wc+wl
        d = mx - mn
        scan  = np.where(scan&lt;mn,mn, scan)
        scan  = np.where(scan&gt;mx,mx, scan)
        scan = (scan-mn)/d
        return scan  
    
    wc= ds[0x28,0x1050].value  #window center
    w=(ds[0x28,0x1051].value) #window width
    ww=int(w/2)
   
    new_wc=wc+(0.3*wc)
    new_ww=(0.8*ww)   
    
    img=ds.pixel_array
    result=get_normalized(img,wc+(0.3*wc),(0.8*ww) )
 
    return result</code></pre>
</details>
</dd>
<dt id="Healthhub.healthhub.segmentation.seg"><code class="name flex">
<span>def <span class="ident">seg</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def seg(self):
    
    import pydicom
    ds=pydicom.dcmread(self.path)
    #img=ds.pixel_array
    try: 
        wc= ds[0x28,0x1050].value  #window center
        w=ds[0x28,0x1051].value #window width
        res = self.generic_window(ds)
    except:
        res = self.bone_seg(ds)
    
    return res</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Healthhub" href="index.html">Healthhub</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Healthhub.healthhub.CV" href="#Healthhub.healthhub.CV">CV</a></code></h4>
<ul class="">
<li><code><a title="Healthhub.healthhub.CV.BlobDetector" href="#Healthhub.healthhub.CV.BlobDetector">BlobDetector</a></code></li>
<li><code><a title="Healthhub.healthhub.CV.EdgeDetection" href="#Healthhub.healthhub.CV.EdgeDetection">EdgeDetection</a></code></li>
<li><code><a title="Healthhub.healthhub.CV.ImageSegmentation" href="#Healthhub.healthhub.CV.ImageSegmentation">ImageSegmentation</a></code></li>
<li><code><a title="Healthhub.healthhub.CV.OpticalFlow" href="#Healthhub.healthhub.CV.OpticalFlow">OpticalFlow</a></code></li>
<li><code><a title="Healthhub.healthhub.CV.TemplateMatching" href="#Healthhub.healthhub.CV.TemplateMatching">TemplateMatching</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Healthhub.healthhub.Image_class" href="#Healthhub.healthhub.Image_class">Image_class</a></code></h4>
<ul class="">
<li><code><a title="Healthhub.healthhub.Image_class.MIP_class" href="#Healthhub.healthhub.Image_class.MIP_class">MIP_class</a></code></li>
<li><code><a title="Healthhub.healthhub.Image_class.calculate_class" href="#Healthhub.healthhub.Image_class.calculate_class">calculate_class</a></code></li>
<li><code><a title="Healthhub.healthhub.Image_class.mask_overlay" href="#Healthhub.healthhub.Image_class.mask_overlay">mask_overlay</a></code></li>
<li><code><a title="Healthhub.healthhub.Image_class.save_class" href="#Healthhub.healthhub.Image_class.save_class">save_class</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Healthhub.healthhub.dicom" href="#Healthhub.healthhub.dicom">dicom</a></code></h4>
</li>
<li>
<h4><code><a title="Healthhub.healthhub.display" href="#Healthhub.healthhub.display">display</a></code></h4>
<ul class="">
<li><code><a title="Healthhub.healthhub.display.display3D" href="#Healthhub.healthhub.display.display3D">display3D</a></code></li>
<li><code><a title="Healthhub.healthhub.display.intensityHist" href="#Healthhub.healthhub.display.intensityHist">intensityHist</a></code></li>
<li><code><a title="Healthhub.healthhub.display.multipleSlice" href="#Healthhub.healthhub.display.multipleSlice">multipleSlice</a></code></li>
<li><code><a title="Healthhub.healthhub.display.plotSlice" href="#Healthhub.healthhub.display.plotSlice">plotSlice</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Healthhub.healthhub.healthhub" href="#Healthhub.healthhub.healthhub">healthhub</a></code></h4>
</li>
<li>
<h4><code><a title="Healthhub.healthhub.modify" href="#Healthhub.healthhub.modify">modify</a></code></h4>
<ul class="">
<li><code><a title="Healthhub.healthhub.modify.image" href="#Healthhub.healthhub.modify.image">image</a></code></li>
<li><code><a title="Healthhub.healthhub.modify.maxDiameter" href="#Healthhub.healthhub.modify.maxDiameter">maxDiameter</a></code></li>
<li><code><a title="Healthhub.healthhub.modify.tag" href="#Healthhub.healthhub.modify.tag">tag</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Healthhub.healthhub.process" href="#Healthhub.healthhub.process">process</a></code></h4>
<ul class="">
<li><code><a title="Healthhub.healthhub.process.getNormalized" href="#Healthhub.healthhub.process.getNormalized">getNormalized</a></code></li>
<li><code><a title="Healthhub.healthhub.process.resize3D" href="#Healthhub.healthhub.process.resize3D">resize3D</a></code></li>
<li><code><a title="Healthhub.healthhub.process.volumeCalculator" href="#Healthhub.healthhub.process.volumeCalculator">volumeCalculator</a></code></li>
<li><code><a title="Healthhub.healthhub.process.windowing" href="#Healthhub.healthhub.process.windowing">windowing</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Healthhub.healthhub.read" href="#Healthhub.healthhub.read">read</a></code></h4>
<ul class="two-column">
<li><code><a title="Healthhub.healthhub.read.Slice" href="#Healthhub.healthhub.read.Slice">Slice</a></code></li>
<li><code><a title="Healthhub.healthhub.read.getFrameOfReference" href="#Healthhub.healthhub.read.getFrameOfReference">getFrameOfReference</a></code></li>
<li><code><a title="Healthhub.healthhub.read.getGeneralStudy" href="#Healthhub.healthhub.read.getGeneralStudy">getGeneralStudy</a></code></li>
<li><code><a title="Healthhub.healthhub.read.getImagePixel" href="#Healthhub.healthhub.read.getImagePixel">getImagePixel</a></code></li>
<li><code><a title="Healthhub.healthhub.read.getImagePlane" href="#Healthhub.healthhub.read.getImagePlane">getImagePlane</a></code></li>
<li><code><a title="Healthhub.healthhub.read.getPatientStudy" href="#Healthhub.healthhub.read.getPatientStudy">getPatientStudy</a></code></li>
<li><code><a title="Healthhub.healthhub.read.getSeriesPlane" href="#Healthhub.healthhub.read.getSeriesPlane">getSeriesPlane</a></code></li>
<li><code><a title="Healthhub.healthhub.read.orientation" href="#Healthhub.healthhub.read.orientation">orientation</a></code></li>
<li><code><a title="Healthhub.healthhub.read.read_scan" href="#Healthhub.healthhub.read.read_scan">read_scan</a></code></li>
<li><code><a title="Healthhub.healthhub.read.scan" href="#Healthhub.healthhub.read.scan">scan</a></code></li>
<li><code><a title="Healthhub.healthhub.read.seriesData" href="#Healthhub.healthhub.read.seriesData">seriesData</a></code></li>
<li><code><a title="Healthhub.healthhub.read.sorted_files" href="#Healthhub.healthhub.read.sorted_files">sorted_files</a></code></li>
<li><code><a title="Healthhub.healthhub.read.tag" href="#Healthhub.healthhub.read.tag">tag</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Healthhub.healthhub.segmentation" href="#Healthhub.healthhub.segmentation">segmentation</a></code></h4>
<ul class="">
<li><code><a title="Healthhub.healthhub.segmentation.boneSeg" href="#Healthhub.healthhub.segmentation.boneSeg">boneSeg</a></code></li>
<li><code><a title="Healthhub.healthhub.segmentation.genericWindow" href="#Healthhub.healthhub.segmentation.genericWindow">genericWindow</a></code></li>
<li><code><a title="Healthhub.healthhub.segmentation.seg" href="#Healthhub.healthhub.segmentation.seg">seg</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>